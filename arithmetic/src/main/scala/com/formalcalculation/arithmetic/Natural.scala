// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import com.formalcalculation.algebra.{Monoid, Semigroup}

import scala.annotation.tailrec
import cats.data.NonEmptyList

/**
 * 自然数（0以上の整数）を二進表現で実装 List[Boolean]を使用してビットを表現（先頭が最下位ビット）
 */
sealed trait Natural {
  def toBits: List[Boolean]
  def isZero: Boolean
  def isOne: Boolean
}

object Natural {

  /** ゼロを表す自然数 */
  case object Zero extends Natural {
    val toBits: List[Boolean] = Nil
    val isZero: Boolean       = true
    val isOne: Boolean        = false
  }

  /** 正の自然数を表現（ビットリスト、先頭が最下位ビット） */
  final case class Positive(bits: NonEmptyList[Boolean]) extends Natural {
    require(bits.last, "Most significant bit must be true")

    val toBits: List[Boolean] = bits.toList
    val isZero: Boolean       = false
    val isOne: Boolean        = bits.toList == List(true)

    /** 正規化：末尾の不要なfalseビットを除去 */
    def normalized: Natural =
      bits.toList.reverse.dropWhile(!_).reverse match {
        case Nil     => Zero
        case x :: xs => Positive(NonEmptyList(x, xs))
      }
  }

  /** 整数値から自然数を作成 */
  def fromInt(n: Int): Natural = {
    require(n >= 0, "Natural number must be non-negative")
    if (n == 0) Zero
    else
      toBinaryList(n) match {
        case Nil     => Zero
        case x :: xs => Positive(NonEmptyList(x, xs))
      }
  }

  /** 整数を二進リストに変換（先頭が最下位ビット） */
  private def toBinaryList(n: Int): List[Boolean] = {
    @tailrec
    def loop(value: Int, acc: List[Boolean]): List[Boolean] = {
      if (value == 0) acc
      else loop(value / 2, (value % 2 == 1) :: acc)
    }
    loop(n, Nil).reverse
  }

  /** 加算 */
  def add(a: Natural, b: Natural): Natural = (a, b) match {
    case (Zero, x) => x
    case (x, Zero) => x
    case (Positive(aBits), Positive(bBits)) =>
      addBits(aBits.toList, bBits.toList) match {
        case Nil     => Zero
        case x :: xs => Positive(NonEmptyList(x, xs))
      }
  }

  /** ビットリストの加算（キャリー付き） */
  private def addBits(a: List[Boolean], b: List[Boolean]): List[Boolean] = {
    @tailrec
    def loop(a: List[Boolean], b: List[Boolean], carry: Boolean, acc: List[Boolean]): List[Boolean] = {
      (a, b) match {
        case (Nil, Nil) => if (carry) (acc :+ true) else acc
        case (Nil, bb)  => loop(List(false), bb, carry, acc)
        case (aa, Nil)  => loop(aa, List(false), carry, acc)
        case (aHead :: aTail, bHead :: bTail) =>
          val sum       = (if (aHead) 1 else 0) + (if (bHead) 1 else 0) + (if (carry) 1 else 0)
          val resultBit = sum % 2 == 1
          val newCarry  = sum >= 2
          loop(aTail, bTail, newCarry, acc :+ resultBit)
      }
    }

    loop(a, b, false, Nil)
  }

  /** 乗算 */
  def multiply(a: Natural, b: Natural): Natural = (a, b) match {
    case (Zero, _) | (_, Zero)                            => Zero
    case (x, Positive(bits)) if bits.toList == List(true) => x // b == 1
    case (Positive(bits), x) if bits.toList == List(true) => x // a == 1
    case (Positive(aBits), Positive(bBits)) =>
      multiplyBits(aBits.toList, bBits.toList)
  }

  /** ビットリストの乗算 */
  private def multiplyBits(a: List[Boolean], b: List[Boolean]): Natural = {
    @tailrec
    def loop(multiplicand: List[Boolean], multiplier: List[Boolean], position: Int, acc: Natural): Natural =
      multiplier match {
        case Nil => acc
        case false :: rest =>
          loop(multiplicand, rest, position + 1, acc)
        case true :: rest =>
          val newAcc = add(
            acc,
            shiftLeft(multiplicand, position) match {
              case Nil     => Zero
              case x :: xs => Positive(NonEmptyList(x, xs))
            }
          )
          loop(multiplicand, rest, position + 1, newAcc)
      }

    loop(a, b, 0, Zero)
  }

  /** ビットリストを左にnビットシフト */
  private def shiftLeft(bits: List[Boolean], n: Int): List[Boolean] = {
    if (n <= 0) bits
    else List.fill(n)(false) ++ bits
  }

  /** 比較（-1: a < b, 0: a == b, 1: a > b） */
  def compare(a: Natural, b: Natural): Int = (a, b) match {
    case (Zero, Zero) => 0
    case (Zero, _)    => -1
    case (_, Zero)    => 1
    case (Positive(aBits), Positive(bBits)) =>
      val aList = aBits.toList
      val bList = bBits.toList
      if (aList.length != bList.length) aList.length.compare(bList.length)
      else compareBits(aList.reverse, bList.reverse) // 最上位ビットから比較
  }

  /** ビットリストの比較（最上位から） */
  @tailrec
  private def compareBits(a: List[Boolean], b: List[Boolean]): Int = (a, b) match {
    case (Nil, Nil)               => 0
    case (true :: _, false :: _)  => 1
    case (false :: _, true :: _)  => -1
    case (_ :: aTail, _ :: bTail) => compareBits(aTail, bTail)
    case _                        => assert(false, "同じ長さなのでここには来ない"); 0
  }

  /** 減算（a >= b の場合のみ定義） */
  def subtract(a: Natural, b: Natural): Option[Natural] = {
    if (compare(a, b) < 0) None
    else Some(subtractUnsafe(a, b))
  }

  /** 減算（結果が負になる場合は未定義） */
  def subtractUnsafe(a: Natural, b: Natural): Natural = (a, b) match {
    case (x, Zero) => x
    case (Positive(aBits), Positive(bBits)) =>
      val result = subtractBits(aBits.toList, bBits.toList)
      result.reverse.dropWhile(!_).reverse match {
        case Nil     => Zero
        case x :: xs => Positive(NonEmptyList(x, xs))
      }
    case (Zero, _) => assert(false, "実際には呼ばれない"); Zero
  }

  /** ビットリストの減算（ボロー付き） */
  private def subtractBits(a: List[Boolean], b: List[Boolean]): List[Boolean] = {
    @tailrec
    def loop(a: List[Boolean], b: List[Boolean], borrow: Boolean, acc: List[Boolean]): List[Boolean] = {
      (a, b) match {
        case (Nil, Nil) => if (borrow) (acc :+ true) else acc
        case (aa, Nil)  => loop(aa, List(false), borrow, acc)
        case (Nil, _)   => assert(false, "実際には呼ばれない"); acc // a >= b が保証されているため
        case (aHead :: aTail, bHead :: bTail) =>
          val aVal                   = if (aHead) 1 else 0
          val bVal                   = if (bHead) 1 else 0
          val borrowVal              = if (borrow) 1 else 0
          val diff                   = aVal - bVal - borrowVal
          val (resultBit, newBorrow) = if (diff >= 0) (diff == 1, false) else (true, true)
          loop(aTail, bTail, newBorrow, acc :+ resultBit)
      }
    }

    loop(a, b, false, Nil)
  }

  /** 等価性 */
  def equal(a: Natural, b: Natural): Boolean = compare(a, b) == 0

  // Monoid instances

  /** Addition monoid for Natural numbers */
  given naturalAdditionSemigroup: Semigroup[Natural] = (x: Natural, y: Natural) => add(x, y)
  given naturalAdditionMonoid: Monoid[Natural]       = Monoid.instance(Zero, add)

  /** Multiplication monoid for Natural numbers */
  given naturalMultiplicationMonoid: Monoid[Natural] = Monoid.instance(fromInt(1), multiply)
}
