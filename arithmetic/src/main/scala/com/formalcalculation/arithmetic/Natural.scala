// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import com.formalcalculation.algebra.{Monoid, Semigroup}
import cats.data.NonEmptyList

trait Repr[N <: Natural] {
  type ReprType
  def repr: N => ReprType
  def from: ReprType => N
}

sealed trait Natural extends ComparisonOps[Natural] with EqualityOps[Natural] {
  def isZero: Boolean
  def isOne: Boolean

  def repr(using r: Repr[this.type]): r.ReprType = r.repr(this)

  // 演算子オーバーロード
  inline def +(other: Natural): Natural         = Natural.add(this, other)
  inline def *(other: Natural): Natural         = Natural.multiply(this, other)
  inline def -(other: Natural): Option[Natural] = Natural.subtract(this, other)

  // 比較演算子の実装
  inline def compare(other: Natural): Int   = Natural.compare(this, other)
  inline def equal(other: Natural): Boolean = Natural.equal(this, other)

  // 後続者（次の自然数）
  inline def succ: Natural = Natural.add(this, Natural.fromInt(1))

  // 文字列表現
  inline def show: String = Natural.naturalToString(this)

  inline def isEven: Boolean = Natural.isEven(this)
  inline def isOdd: Boolean  = !isEven
}
case object NaturalZero extends Natural {
  def isZero: Boolean = true
  def isOne: Boolean  = false
}
sealed trait NaturalPositive extends Natural {
  def isZero: Boolean = false
}

// Implementation class for positive natural numbers
final case class INaturalPositive(bits: cats.data.NonEmptyList[Boolean]) extends NaturalPositive {
  require(bits.last, "Most significant bit must be true")

  // The Repr type class will handle bit representation access

  inline def isOne: Boolean = bits.toList == List(true)

  /** 正規化：末尾の不要なfalseビットを除去 */
  def normalized: Natural =
    bits.toList.reverse.dropWhile(!_).reverse match {
      case Nil     => NaturalZero
      case x :: xs => INaturalPositive(cats.data.NonEmptyList(x, xs))
    }
}

trait NaturalOps {
  def add(a: Natural, b: Natural): Natural
  def multiply(a: Natural, b: Natural): Natural
  def subtract(a: Natural, b: Natural): Option[Natural]
  def subtractUnsafe(a: Natural, b: Natural): Natural
  def compare(a: Natural, b: Natural): Int
  def equal(a: Natural, b: Natural): Boolean
  def fromInt(n: Int): Natural
  def naturalToString(n: Natural): String
  def naturalToInt(n: Natural): Int
  def isEven(n: Natural): Boolean
  def isOdd(n: Natural): Boolean = !isEven(n)
}

object Natural {

  // Factory methods for creating instances
  inline def zero: Natural = NaturalZero
  inline def positiveFromBits(bits: cats.data.NonEmptyList[Boolean]): Natural = INaturalPositive(bits)
  
  // Repr access methods
  inline def toRepr(n: Natural)(using r: Repr[Natural]): r.ReprType = r.repr(n)
  inline def fromRepr[R](repr: R)(using r: Repr[Natural] { type ReprType = R }): Natural = r.from(repr)



  // Default implementation
  private val defaultOps: NaturalOps = impl.NaturalOpsImpl

  /** 整数値から自然数を作成 */
  inline def fromInt(n: Int): Natural = defaultOps.fromInt(n)

  /** 加算 */
  inline def add(a: Natural, b: Natural): Natural = defaultOps.add(a, b)

  /** 乗算 */
  inline def multiply(a: Natural, b: Natural): Natural = defaultOps.multiply(a, b)

  /** 比較（-1: a < b, 0: a == b, 1: a > b） */
  inline def compare(a: Natural, b: Natural): Int = defaultOps.compare(a, b)

  /** 減算（a >= b の場合のみ定義） */
  inline def subtract(a: Natural, b: Natural): Option[Natural] = defaultOps.subtract(a, b)

  /** 減算（結果が負になる場合は未定義） */
  inline def subtractUnsafe(a: Natural, b: Natural): Natural = defaultOps.subtractUnsafe(a, b)

  /** 等価性 */
  inline def equal(a: Natural, b: Natural): Boolean = defaultOps.equal(a, b)

  /** 後続者（次の自然数） */
  inline def succ(n: Natural): Natural = add(n, fromInt(1))

  /** 偶数判定 */
  inline def isEven(n: Natural): Boolean = defaultOps.isEven(n)

  /** 自然数を文字列に変換 */
  inline def naturalToString(n: Natural): String = defaultOps.naturalToString(n)

  /** 自然数をIntに変換 */
  inline def naturalToInt(n: Natural): Int = defaultOps.naturalToInt(n)

  // Monoid instances
  /** Addition monoid for Natural numbers */
  given naturalAdditionSemigroup: Semigroup[Natural] = (x: Natural, y: Natural) => add(x, y)
  given naturalAdditionMonoid: Monoid[Natural]       = Monoid.instance(zero, add)

  /** Multiplication monoid for Natural numbers */
  given naturalMultiplicationMonoid: Monoid[Natural] = Monoid.instance(fromInt(1), multiply)
}
