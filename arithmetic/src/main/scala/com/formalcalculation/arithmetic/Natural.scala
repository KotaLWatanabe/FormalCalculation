// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import com.formalcalculation.algebra.Monoid

import scala.annotation.tailrec
import cats.data.NonEmptyList

/** 自然数（0以上の整数）を二進表現で実装
 * List[Boolean]を使用してビットを表現（先頭が最下位ビット）
 */
sealed trait Natural {
  def toBits: List[Boolean]
  def isZero: Boolean
  def isOne: Boolean
}

object Natural {
  
  /** ゼロを表す自然数 */
  case object Zero extends Natural {
    val toBits: List[Boolean] = Nil
    val isZero: Boolean = true
    val isOne: Boolean = false
  }
  
  /** 正の自然数を表現（ビットリスト、先頭が最下位ビット） */
  final case class Positive(bits: NonEmptyList[Boolean]) extends Natural {
    require(bits.last, "Most significant bit must be true")
    
    val toBits: List[Boolean] = bits.toList
    val isZero: Boolean = false
    val isOne: Boolean = bits.toList == List(true)
    
    /** 正規化：末尾の不要なfalseビットを除去 */
    def normalized: Natural = {
      val trimmed = bits.toList.reverse.dropWhile(!_).reverse
      if (trimmed.isEmpty) Zero 
      else NonEmptyList.fromList(trimmed) match {
        case Some(nel) => Positive(nel)
        case None => Zero
      }
    }
  }
  
  /** 整数値から自然数を作成 */
  def fromInt(n: Int): Natural = {
    require(n >= 0, "Natural number must be non-negative")
    if (n == 0) Zero
    else {
      val bits = toBinaryList(n)
      NonEmptyList.fromList(bits) match {
        case Some(nel) => Positive(nel)
        case None => Zero
      }
    }
  }
  
  /** 整数を二進リストに変換（先頭が最下位ビット） */
  private def toBinaryList(n: Int): List[Boolean] = {
    @tailrec
    def loop(value: Int, acc: List[Boolean]): List[Boolean] = {
      if (value == 0) acc
      else loop(value / 2, (value % 2 == 1) :: acc)
    }
    loop(n, Nil).reverse
  }
  
  /** 加算 */
  def add(a: Natural, b: Natural): Natural = (a, b) match {
    case (Zero, x) => x
    case (x, Zero) => x
    case (Positive(aBits), Positive(bBits)) =>
      val result = addBits(aBits.toList, bBits.toList, false)
      if (result.isEmpty) Zero 
      else NonEmptyList.fromList(result) match {
        case Some(nel) => Positive(nel)
        case None => Zero
      }
  }
  
  /** ビットリストの加算（キャリー付き） */
  private def addBits(a: List[Boolean], b: List[Boolean], carry: Boolean): List[Boolean] = 
    (a, b) match {
      case (Nil, Nil) => if (carry) List(true) else Nil
      case (Nil, bb) => addBits(List(false), bb, carry)
      case (aa, Nil) => addBits(aa, List(false), carry)
      case (aHead :: aTail, bHead :: bTail) =>
        val sum = (if (aHead) 1 else 0) + (if (bHead) 1 else 0) + (if (carry) 1 else 0)
        val resultBit = sum % 2 == 1
        val newCarry = sum >= 2
        resultBit :: addBits(aTail, bTail, newCarry)
    }
  
  /** 乗算 */
  def multiply(a: Natural, b: Natural): Natural = (a, b) match {
    case (Zero, _) | (_, Zero) => Zero
    case (x, Positive(bits)) if bits.toList == List(true) => x // b == 1
    case (Positive(bits), x) if bits.toList == List(true) => x // a == 1
    case (Positive(aBits), Positive(bBits)) =>
      multiplyBits(aBits.toList, bBits.toList)
  }
  
  /** ビットリストの乗算 */
  private def multiplyBits(a: List[Boolean], b: List[Boolean]): Natural = {
    @tailrec
    def loop(multiplicand: List[Boolean], multiplier: List[Boolean], position: Int, acc: Natural): Natural =
      multiplier match {
        case Nil => acc
        case false :: rest => 
          loop(multiplicand, rest, position + 1, acc)
        case true :: rest =>
          val shifted = shiftLeft(multiplicand, position)
          val newAcc = add(acc, if (shifted.isEmpty) Zero 
                          else NonEmptyList.fromList(shifted) match {
                            case Some(nel) => Positive(nel)
                            case None => Zero
                          })
          loop(multiplicand, rest, position + 1, newAcc)
      }
    loop(a, b, 0, Zero)
  }
  
  /** ビットリストを左にnビットシフト */
  private def shiftLeft(bits: List[Boolean], n: Int): List[Boolean] = {
    if (n <= 0) bits
    else List.fill(n)(false) ++ bits
  }
  
  /** 比較（-1: a < b, 0: a == b, 1: a > b） */
  def compare(a: Natural, b: Natural): Int = (a, b) match {
    case (Zero, Zero) => 0
    case (Zero, _) => -1
    case (_, Zero) => 1
    case (Positive(aBits), Positive(bBits)) =>
      val aList = aBits.toList
      val bList = bBits.toList
      if (aList.length != bList.length) aList.length.compare(bList.length)
      else compareBits(aList.reverse, bList.reverse) // 最上位ビットから比較
  }
  
  /** ビットリストの比較（最上位から） */
  @tailrec
  private def compareBits(a: List[Boolean], b: List[Boolean]): Int = (a, b) match {
    case (Nil, Nil) => 0
    case (true :: _, false :: _) => 1
    case (false :: _, true :: _) => -1
    case (_ :: aTail, _ :: bTail) => compareBits(aTail, bTail)
    case _ => assert(false, "同じ長さなのでここには来ない"); 0
  }
  
  /** 減算（a >= b の場合のみ定義） */
  def subtract(a: Natural, b: Natural): Option[Natural] = {
    if (compare(a, b) < 0) None
    else Some(subtractUnsafe(a, b))
  }
  
  /** 減算（結果が負になる場合は未定義） */
  def subtractUnsafe(a: Natural, b: Natural): Natural = (a, b) match {
    case (x, Zero) => x
    case (Zero, _) => Zero // 実際には呼ばれない
    case (Positive(aBits), Positive(bBits)) =>
      val result = subtractBits(aBits.toList, bBits.toList, false)
      val trimmed = result.reverse.dropWhile(!_).reverse
      if (trimmed.isEmpty) Zero 
      else NonEmptyList.fromList(trimmed) match {
        case Some(nel) => Positive(nel)
        case None => Zero
      }
  }
  
  /** ビットリストの減算（ボロー付き） */
  private def subtractBits(a: List[Boolean], b: List[Boolean], borrow: Boolean): List[Boolean] = 
    (a, b) match {
      case (Nil, Nil) => Nil
      case (aa, Nil) => subtractBits(aa, List(false), borrow)
      case (Nil, _) => Nil // 実際には呼ばれない（a >= b が保証されている）
      case (aHead :: aTail, bHead :: bTail) =>
        val aVal = if (aHead) 1 else 0
        val bVal = if (bHead) 1 else 0
        val borrowVal = if (borrow) 1 else 0
        val diff = aVal - bVal - borrowVal
        val (resultBit, newBorrow) = if (diff >= 0) (diff == 1, false) else (true, true)
        resultBit :: subtractBits(aTail, bTail, newBorrow)
    }
  
  /** 等価性 */
  def equal(a: Natural, b: Natural): Boolean = compare(a, b) == 0
  
  // Monoid instances
  
  /** Addition monoid for Natural numbers */
  given naturalAdditionMonoid: Monoid[Natural] = Monoid.instance(Zero, add)
  
  /** Multiplication monoid for Natural numbers */
  given naturalMultiplicationMonoid: Monoid[Natural] = Monoid.instance(fromInt(1), multiply)
}