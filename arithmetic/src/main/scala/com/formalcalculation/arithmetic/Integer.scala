// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import scala.annotation.tailrec
import cats.data.NonEmptyList

/** 整数を符号付き自然数として実装 */
sealed trait Integer {
  def isZero: Boolean
  def isPositive: Boolean
  def isNegative: Boolean
  def abs: Natural
  def sign: Sign
}

/** 符号 */
sealed trait Sign
object Sign {
  case object Positive extends Sign
  case object Negative extends Sign
  case object Zero     extends Sign
}

object Integer {

  /** ゼロ */
  case object Zero extends Integer {
    val isZero: Boolean     = true
    val isPositive: Boolean = false
    val isNegative: Boolean = false
    val abs: Natural        = Natural.Zero
    val sign: Sign          = Sign.Zero
  }

  /** 正の整数 */
  final case class Positive(value: Natural) extends Integer {
    require(!value.isZero, "Positive integer cannot be zero")

    val isZero: Boolean     = false
    val isPositive: Boolean = true
    val isNegative: Boolean = false
    val abs: Natural        = value
    val sign: Sign          = Sign.Positive
  }

  /** 負の整数 */
  final case class Negative(value: Natural) extends Integer {
    require(!value.isZero, "Negative integer cannot be zero")

    val isZero: Boolean     = false
    val isPositive: Boolean = false
    val isNegative: Boolean = true
    val abs: Natural        = value
    val sign: Sign          = Sign.Negative
  }

  /** 自然数から整数を作成 */
  def fromNatural(n: Natural): Integer = n match {
    case Natural.Zero          => Zero
    case pos: Natural.Positive => Positive(pos)
  }

  /** 符号と自然数から整数を作成 */
  def fromSignAndNatural(sign: Sign, value: Natural): Integer = (sign, value) match {
    case (Sign.Zero, _) | (_, Natural.Zero)     => Zero
    case (Sign.Positive, pos: Natural.Positive) => Positive(pos)
    case (Sign.Negative, pos: Natural.Positive) => Negative(pos)
  }

  /** Int値から整数を作成 */
  def fromInt(n: Int): Integer = {
    if (n == 0) Zero
    else if (n > 0) Positive(Natural.fromInt(n))
    else Negative(Natural.fromInt(-n))
  }

  /** 加算 */
  def add(a: Integer, b: Integer): Integer = (a, b) match {
    case (Zero, x) => x
    case (x, Zero) => x
    case (Positive(av), Positive(bv)) =>
      fromNatural(Natural.add(av, bv))
    case (Negative(av), Negative(bv)) =>
      Negative(Natural.add(av, bv))
    case (Positive(av), Negative(bv)) =>
      Natural.compare(av, bv) match {
        case 0  => Zero
        case 1  => fromNatural(Natural.subtractUnsafe(av, bv))
        case -1 => Negative(Natural.subtractUnsafe(bv, av))
      }
    case (Negative(av), Positive(bv)) =>
      Natural.compare(av, bv) match {
        case 0  => Zero
        case 1  => Negative(Natural.subtractUnsafe(av, bv))
        case -1 => fromNatural(Natural.subtractUnsafe(bv, av))
      }
  }

  /** 減算 */
  def subtract(a: Integer, b: Integer): Integer = add(a, negate(b))

  /** 符号反転 */
  def negate(a: Integer): Integer = a match {
    case Zero        => Zero
    case Positive(v) => Negative(v)
    case Negative(v) => Positive(v)
  }

  /** 乗算 */
  def multiply(a: Integer, b: Integer): Integer = (a, b) match {
    case (Zero, _) | (_, Zero) => Zero
    case (Positive(av), Positive(bv)) =>
      fromNatural(Natural.multiply(av, bv))
    case (Negative(av), Negative(bv)) =>
      fromNatural(Natural.multiply(av, bv))
    case (Positive(av), Negative(bv)) =>
      Negative(Natural.multiply(av, bv))
    case (Negative(av), Positive(bv)) =>
      Negative(Natural.multiply(av, bv))
  }

  /** 除算（商と余り） */
  def divideWithRemainder(dividend: Integer, divisor: Integer): Option[(Integer, Integer)] = {
    if (divisor.isZero) None
    else {
      val (quotNat, remNat) = divideNaturals(dividend.abs, divisor.abs)
      val quotSign = (dividend.sign, divisor.sign) match {
        case (Sign.Zero, _)                                                  => Sign.Zero
        case (Sign.Positive, Sign.Positive) | (Sign.Negative, Sign.Negative) => Sign.Positive
        case _                                                               => Sign.Negative
      }
      val remSign = dividend.sign

      Some(
        (
          fromSignAndNatural(quotSign, quotNat),
          fromSignAndNatural(remSign, remNat)
        )
      )
    }
  }

  /** 自然数の除算（商と余り） */
  private def divideNaturals(dividend: Natural, divisor: Natural): (Natural, Natural) =
    (dividend, divisor) match {
      case (Natural.Zero, _)                           => (Natural.Zero, Natural.Zero)
      case (_, Natural.Zero)                           => throw new IllegalArgumentException("Division by zero")
      case _ if Natural.compare(dividend, divisor) < 0 => (Natural.Zero, dividend)
      case _                                           =>
        // 長除法による実装
        longDivision(dividend, divisor)
    }

  /** 長除法による自然数の除算 */
  private def longDivision(dividend: Natural, divisor: Natural): (Natural, Natural) = {
    val dividendBits = dividend.toBits.reverse // 最上位ビットから

    @tailrec
    def loop(bits: List[Boolean], currentRemainder: Natural, quotientBits: List[Boolean]): (Natural, Natural) =
      bits match {
        case Nil =>
          val quotient = quotientBits.reverse match {
            case Nil => Natural.Zero
            case qBits =>
              NonEmptyList.fromList(qBits) match {
                case Some(nel) => Natural.Positive(nel)
                case None      => Natural.Zero
              }
          }
          (quotient, currentRemainder)
        case bit :: remainingBits =>
          val newRemainder = shiftAndAdd(currentRemainder, bit)
          if (Natural.compare(newRemainder, divisor) >= 0) {
            val subtracted = Natural.subtractUnsafe(newRemainder, divisor)
            loop(remainingBits, subtracted, true :: quotientBits)
          } else {
            loop(remainingBits, newRemainder, false :: quotientBits)
          }
      }

    loop(dividendBits, Natural.Zero, Nil)
  }

  /** 自然数を1ビット左シフトしてビットを追加 */
  private def shiftAndAdd(n: Natural, bit: Boolean): Natural = n match {
    case Natural.Zero => if (bit) Natural.Positive(NonEmptyList.of(true)) else Natural.Zero
    case Natural.Positive(bits) =>
      val newBits = bit :: bits.toList
      NonEmptyList.fromList(newBits) match {
        case Some(nel) => Natural.Positive(nel)
        case None      => Natural.Zero
      }
  }

  /** 商のみを取得 */
  def divide(a: Integer, b: Integer): Option[Integer] =
    divideWithRemainder(a, b).map(_._1)

  /** 余りのみを取得 */
  def remainder(a: Integer, b: Integer): Option[Integer] =
    divideWithRemainder(a, b).map(_._2)

  /** べき乗（指数は自然数） */
  def power(base: Integer, exponent: Natural): Integer = exponent match {
    case Natural.Zero                                        => fromInt(1)
    case _ if base.isZero                                    => Zero
    case Natural.Positive(bits) if bits.toList == List(true) => base // exponent == 1
    case _                                                   =>
      // 二進法によるべき乗
      binaryPower(base, exponent)
  }

  /** 二進法によるべき乗計算 */
  private def binaryPower(base: Integer, exponent: Natural): Integer = {
    @tailrec
    def loop(currentBase: Integer, exp: Natural, acc: Integer): Integer = exp match {
      case Natural.Zero => acc
      case Natural.Positive(bits) =>
        val newAcc  = if (bits.head) multiply(acc, currentBase) else acc
        val newBase = multiply(currentBase, currentBase)
        val newExp  = shiftRight(exp)
        loop(newBase, newExp, newAcc)
    }
    loop(base, exponent, fromInt(1))
  }

  /** 自然数を1ビット右シフト */
  private def shiftRight(n: Natural): Natural = n match {
    case Natural.Zero => Natural.Zero
    case Natural.Positive(bits) =>
      val bitsList = bits.toList
      bitsList match {
        case List(_) => Natural.Zero
        case _ :: tailBits =>
          if (tailBits.isEmpty) Natural.Zero
          else {
            val trimmed = tailBits.reverse.dropWhile(!_).reverse
            if (trimmed.isEmpty) Natural.Zero
            else
              NonEmptyList.fromList(trimmed) match {
                case Some(nel) => Natural.Positive(nel)
                case None      => Natural.Zero
              }
          }
        case Nil => assert(false, "NonEmptyList cannot be empty"); Natural.Zero
      }
  }

  /** 比較（-1: a < b, 0: a == b, 1: a > b） */
  def compare(a: Integer, b: Integer): Int = (a, b) match {
    case _ if a.isZero && b.isZero         => 0
    case _ if a.isZero                     => if (b.isPositive) -1 else 1
    case _ if b.isZero                     => if (a.isPositive) 1 else -1
    case _ if a.isPositive && b.isNegative => 1
    case _ if a.isNegative && b.isPositive => -1
    case (Positive(av), Positive(bv))      => Natural.compare(av, bv)
    case (Negative(av), Negative(bv))      => Natural.compare(bv, av)
    case _                                 => assert(false, "すべてのケースは上記のガードで処理済み"); 0
  }

  /** 等価性 */
  def equal(a: Integer, b: Integer): Boolean = compare(a, b) == 0

  /** 絶対値 */
  def abs(a: Integer): Natural = a.abs
}
