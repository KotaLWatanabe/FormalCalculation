// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import scala.annotation.tailrec

/** 演算子とimplicitクラスの定義 */
object IntegerOps {
  
  /** 自然数の演算子 */
  implicit class NaturalOps(val n: Natural) extends AnyVal {
    def +(other: Natural): Natural = Natural.add(n, other)
    def *(other: Natural): Natural = Natural.multiply(n, other)
    def -(other: Natural): Option[Natural] = Natural.subtract(n, other)
    def compare(other: Natural): Int = Natural.compare(n, other)
    def ==(other: Natural): Boolean = Natural.equal(n, other)
    def !=(other: Natural): Boolean = !Natural.equal(n, other)
    def <(other: Natural): Boolean = Natural.compare(n, other) < 0
    def <=(other: Natural): Boolean = Natural.compare(n, other) <= 0
    def >(other: Natural): Boolean = Natural.compare(n, other) > 0
    def >=(other: Natural): Boolean = Natural.compare(n, other) >= 0
    def toInt: Int = naturalToInt(n)
  }
  
  /** 整数の演算子 */
  implicit class IntegerOps(val i: Integer) extends AnyVal {
    def +(other: Integer): Integer = Integer.add(i, other)
    def -(other: Integer): Integer = Integer.subtract(i, other)
    def *(other: Integer): Integer = Integer.multiply(i, other)
    def /(other: Integer): Option[Integer] = Integer.divide(i, other)
    def %(other: Integer): Option[Integer] = Integer.remainder(i, other)
    def /%(other: Integer): Option[(Integer, Integer)] = Integer.divideWithRemainder(i, other)
    def **(exponent: Natural): Integer = Integer.power(i, exponent)
    def unary_- : Integer = Integer.negate(i)
    def compare(other: Integer): Int = Integer.compare(i, other)
    def ==(other: Integer): Boolean = Integer.equal(i, other)
    def !=(other: Integer): Boolean = !Integer.equal(i, other)
    def <(other: Integer): Boolean = Integer.compare(i, other) < 0
    def <=(other: Integer): Boolean = Integer.compare(i, other) <= 0
    def >(other: Integer): Boolean = Integer.compare(i, other) > 0
    def >=(other: Integer): Boolean = Integer.compare(i, other) >= 0
    def abs: Natural = Integer.abs(i)
    def toInt: Int = integerToInt(i)
    def divide(other: Integer): Option[(Integer, Integer)] = Integer.divideWithRemainder(i, other)
  }
  
  /** Int から Integer への暗黙的変換 */
  implicit def intToInteger(n: Int): Integer = Integer.fromInt(n)
  
  /** Int から Natural への暗黙的変換（非負の場合のみ） */
  implicit def intToNatural(n: Int): Natural = {
    require(n >= 0, s"Cannot convert negative integer $n to Natural")
    Natural.fromInt(n)
  }
  
  /** ゼロでない整数の演算子 */
  implicit class NonZeroIntegerOps(val nz: NonZeroInteger) extends AnyVal {
    def +(other: NonZeroInteger): Integer = NonZeroInteger.add(nz, other)
    def -(other: NonZeroInteger): Integer = NonZeroInteger.subtract(nz, other)
    def *(other: NonZeroInteger): NonZeroInteger = NonZeroInteger.multiply(nz, other)
    def /(other: NonZeroInteger): Integer = NonZeroInteger.divide(nz, other)
    def %(other: NonZeroInteger): Integer = NonZeroInteger.remainder(nz, other)
    def /%(other: NonZeroInteger): (Integer, Integer) = NonZeroInteger.divideWithRemainder(nz, other)
    def **(exponent: Natural): Integer = NonZeroInteger.power(nz, exponent)
    def unary_- : NonZeroInteger = NonZeroInteger.negate(nz)
    def compare(other: NonZeroInteger): Int = NonZeroInteger.compare(nz, other)
    def ==(other: NonZeroInteger): Boolean = NonZeroInteger.equal(nz, other)
    def !=(other: NonZeroInteger): Boolean = !NonZeroInteger.equal(nz, other)
    def <(other: NonZeroInteger): Boolean = NonZeroInteger.compare(nz, other) < 0
    def <=(other: NonZeroInteger): Boolean = NonZeroInteger.compare(nz, other) <= 0
    def >(other: NonZeroInteger): Boolean = NonZeroInteger.compare(nz, other) > 0
    def >=(other: NonZeroInteger): Boolean = NonZeroInteger.compare(nz, other) >= 0
    def abs: Natural.Positive = NonZeroInteger.abs(nz)
  }
  
  /** 便利な定数 */
  object Constants {
    val Zero: Integer = Integer.Zero
    val One: Integer = Integer.fromInt(1)
    val MinusOne: Integer = Integer.fromInt(-1)
    val Two: Integer = Integer.fromInt(2)
    
    val NaturalZero: Natural = Natural.Zero
    val NaturalOne: Natural = Natural.fromInt(1)
    val NaturalTwo: Natural = Natural.fromInt(2)
    
    val NonZeroOne: NonZeroInteger = NonZeroInteger.fromIntUnsafe(1)
    val NonZeroMinusOne: NonZeroInteger = NonZeroInteger.fromIntUnsafe(-1)
    val NonZeroTwo: NonZeroInteger = NonZeroInteger.fromIntUnsafe(2)
  }
  
  /** 文字列表現 */
  implicit class NaturalShow(val n: Natural) extends AnyVal {
    def show: String = naturalToString(n)
  }
  
  implicit class IntegerShow(val i: Integer) extends AnyVal {
    def show: String = integerToString(i)
  }
  
  implicit class NonZeroIntegerShow(val nz: NonZeroInteger) extends AnyVal {
    def show: String = integerToString(nz.toInteger)
  }
  
  /** 自然数を文字列に変換 */
  private def naturalToString(n: Natural): String = n match {
    case Natural.Zero => "0"
    case Natural.Positive(bits) => 
      // 2進数から10進数への変換
      bitsToDecimalString(bits.toList)
  }
  
  /** 整数を文字列に変換 */
  private def integerToString(i: Integer): String = i match {
    case Integer.Zero => "0"
    case Integer.Positive(value) => naturalToString(value)
    case Integer.Negative(value) => "-" + naturalToString(value)
  }
  
  /** ビット列を10進文字列に変換 */
  private def bitsToDecimalString(bits: List[Boolean]): String = {
    // 2進数から10進数への変換
    def bitsToNat(bs: List[Boolean]): Natural = bs match {
      case Nil => Natural.Zero
      case head :: tail =>
        val tailValue = bitsToNat(tail)
        val doubled = Natural.multiply(tailValue, Natural.fromInt(2))
        if (head) Natural.add(doubled, Natural.fromInt(1)) else doubled
    }
    
    val nat = bitsToNat(bits)
    natToDecimalString(nat)
  }
  
  /** 自然数を10進文字列に変換（簡易実装） */
  private def natToDecimalString(n: Natural): String = {
    @tailrec
    def loop(current: Natural, acc: String): String = current match {
      case Natural.Zero => if (acc.isEmpty) "0" else acc
      case _ =>
        val ten = Natural.fromInt(10)
        Natural.subtract(current, ten) match {
          case Some(_) => 
            // current >= 10 の場合
            val quotient = divideByTen(current)
            val digit = subtractionsToGetRemainder(current, ten)
            loop(quotient, digit.toString + acc)
          case None => 
            // current < 10 の場合
            val digit = naturalToSingleDigit(current)
            digit.toString + acc
        }
    }
    loop(n, "")
  }
  
  /** 自然数を10で割った商を計算（簡易実装） */
  private def divideByTen(n: Natural): Natural = {
    val ten = Natural.fromInt(10)
    var quotient: Natural = Natural.Zero
    val one = Natural.fromInt(1)
    
    // 10 * quotient + remainder = n となるquotientを見つける
    while (Natural.compare(Natural.add(Natural.multiply(quotient, ten), ten), n) <= 0) {
      quotient = Natural.add(quotient, one)
    }
    quotient
  }
  
  /** 自然数から単一桁の数字を取得 */
  private def naturalToSingleDigit(n: Natural): Int = {
    val values = (0 to 9).map(Natural.fromInt)
    values.indexWhere(Natural.equal(n, _)) match {
      case -1 => throw new IllegalArgumentException(s"Natural number is not a single digit: $n")
      case digit => digit
    }
  }
  
  /** nからmを何回引けるかを計算 */
  private def subtractionsToGetRemainder(n: Natural, m: Natural): Int = {
    @tailrec
    def loop(current: Natural, count: Int): Int =
      Natural.subtract(current, m) match {
        case Some(remainder) => loop(remainder, count + 1)
        case None => count
      }
    loop(n, 0)
  }
  
  /** 自然数をIntに変換 */
  private def naturalToInt(n: Natural): Int = n match {
    case Natural.Zero => 0
    case Natural.Positive(bits) =>
      bits.toList.zipWithIndex.foldLeft(0) { case (acc, (bit, index)) =>
        if (bit) acc + (1 << index) else acc
      }
  }
  
  /** 整数をIntに変換 */
  private def integerToInt(i: Integer): Int = i match {
    case Integer.Zero => 0
    case Integer.Positive(value) => naturalToInt(value)
    case Integer.Negative(value) => -naturalToInt(value)
  }
}