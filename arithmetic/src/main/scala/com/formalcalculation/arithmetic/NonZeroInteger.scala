// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import scala.annotation.tailrec
import cats.data.NonEmptyList

/** ゼロを含まない整数 */
sealed trait NonZeroInteger {
  def isPositive: Boolean
  def isNegative: Boolean
  def abs: Natural.Positive
  def sign: Sign
  def toInteger: Integer
}

object NonZeroInteger {
  
  /** 正のゼロでない整数 */
  final case class Positive(value: Natural.Positive) extends NonZeroInteger {
    val isPositive: Boolean = true
    val isNegative: Boolean = false
    val abs: Natural.Positive = value
    val sign: Sign = Sign.Positive
    val toInteger: Integer = Integer.Positive(value)
  }
  
  /** 負のゼロでない整数 */
  final case class Negative(value: Natural.Positive) extends NonZeroInteger {
    val isPositive: Boolean = false
    val isNegative: Boolean = true
    val abs: Natural.Positive = value
    val sign: Sign = Sign.Negative
    val toInteger: Integer = Integer.Negative(value)
  }
  
  /** 自然数からゼロでない整数を作成 */
  def fromNatural(n: Natural.Positive): NonZeroInteger = Positive(n)
  
  /** 符号と正の自然数からゼロでない整数を作成 */
  def fromSignAndNatural(sign: Sign, value: Natural.Positive): NonZeroInteger = sign match {
    case Sign.Positive => Positive(value)
    case Sign.Negative => Negative(value)
    case Sign.Zero => throw new IllegalArgumentException("Cannot create NonZeroInteger with zero sign")
  }
  
  /** Int値からゼロでない整数を作成 */
  def fromInt(n: Int): Option[NonZeroInteger] = {
    if (n == 0) None
    else if (n > 0) {
      Natural.fromInt(n) match {
        case pos: Natural.Positive => Some(Positive(pos))
        case Natural.Zero => None // これは実際には起こらない
      }
    } else {
      Natural.fromInt(-n) match {
        case pos: Natural.Positive => Some(Negative(pos))
        case Natural.Zero => None // これは実際には起こらない
      }
    }
  }
  
  /** Int値からゼロでない整数を作成（安全でない版） */
  def fromIntUnsafe(n: Int): NonZeroInteger = {
    require(n != 0, "Cannot create NonZeroInteger from zero")
    fromInt(n).get
  }
  
  /** 整数からゼロでない整数を作成 */
  def fromInteger(i: Integer): Option[NonZeroInteger] = i match {
    case Integer.Zero => None
    case Integer.Positive(value) => Some(Positive(value.asInstanceOf[Natural.Positive]))
    case Integer.Negative(value) => Some(Negative(value.asInstanceOf[Natural.Positive]))
  }
  
  /** 加算 */
  def add(a: NonZeroInteger, b: NonZeroInteger): Integer = (a, b) match {
    case (Positive(av), Positive(bv)) => 
      Integer.fromNatural(Natural.add(av, bv))
    case (Negative(av), Negative(bv)) => 
      Integer.Negative(Natural.add(av, bv))
    case (Positive(av), Negative(bv)) =>
      Natural.compare(av, bv) match {
        case 0 => Integer.Zero
        case 1 => Integer.fromNatural(Natural.subtractUnsafe(av, bv))
        case -1 => Integer.Negative(Natural.subtractUnsafe(bv, av))
      }
    case (Negative(av), Positive(bv)) =>
      Natural.compare(av, bv) match {
        case 0 => Integer.Zero
        case 1 => Integer.Negative(Natural.subtractUnsafe(av, bv))
        case -1 => Integer.fromNatural(Natural.subtractUnsafe(bv, av))
      }
  }
  
  /** 減算 */
  def subtract(a: NonZeroInteger, b: NonZeroInteger): Integer = add(a, negate(b))
  
  /** 符号反転 */
  def negate(a: NonZeroInteger): NonZeroInteger = a match {
    case Positive(v) => Negative(v)
    case Negative(v) => Positive(v)
  }
  
  /** 乗算 */
  def multiply(a: NonZeroInteger, b: NonZeroInteger): NonZeroInteger = (a, b) match {
    case (Positive(av), Positive(bv)) => 
      Positive(Natural.multiply(av, bv).asInstanceOf[Natural.Positive])
    case (Negative(av), Negative(bv)) => 
      Positive(Natural.multiply(av, bv).asInstanceOf[Natural.Positive])
    case (Positive(av), Negative(bv)) => 
      Negative(Natural.multiply(av, bv).asInstanceOf[Natural.Positive])
    case (Negative(av), Positive(bv)) => 
      Negative(Natural.multiply(av, bv).asInstanceOf[Natural.Positive])
  }
  
  /** 除算（商と余り） */
  def divideWithRemainder(dividend: NonZeroInteger, divisor: NonZeroInteger): (Integer, Integer) = {
    val (quotNat, remNat) = divideNaturals(dividend.abs, divisor.abs)
    val quotSign = (dividend.sign, divisor.sign) match {
      case (Sign.Positive, Sign.Positive) | (Sign.Negative, Sign.Negative) => Sign.Positive
      case _ => Sign.Negative
    }
    val remSign = dividend.sign
    
    (
      Integer.fromSignAndNatural(quotSign, quotNat),
      Integer.fromSignAndNatural(remSign, remNat)
    )
  }
  
  /** 自然数の除算（商と余り） */
  private def divideNaturals(dividend: Natural.Positive, divisor: Natural.Positive): (Natural, Natural) = {
    val dividendInt = Integer.Positive(dividend)
    val divisorInt = Integer.Positive(divisor)
    Integer.divideWithRemainder(dividendInt, divisorInt) match {
      case Some((quot, rem)) => (Integer.abs(quot), Integer.abs(rem))
      case None => throw new IllegalArgumentException("Division failed") // これは実際には起こらない
    }
  }
  
  /** 商のみを取得 */
  def divide(a: NonZeroInteger, b: NonZeroInteger): Integer = 
    divideWithRemainder(a, b)._1
  
  /** 余りのみを取得 */
  def remainder(a: NonZeroInteger, b: NonZeroInteger): Integer = 
    divideWithRemainder(a, b)._2
  
  /** べき乗（指数は自然数） */
  def power(base: NonZeroInteger, exponent: Natural): Integer = exponent match {
    case Natural.Zero => Integer.fromInt(1)
    case Natural.Positive(bits) if bits.toList == List(true) => base.toInteger // exponent == 1
    case _ => 
      // 二進法によるべき乗
      binaryPower(base, exponent)
  }
  
  /** 二進法によるべき乗計算 */
  private def binaryPower(base: NonZeroInteger, exponent: Natural): Integer = {
    @tailrec
    def loop(currentBase: Integer, exp: Natural, acc: Integer): Integer = exp match {
      case Natural.Zero => acc
      case Natural.Positive(bits) =>
        val newAcc = if (bits.head) Integer.multiply(acc, currentBase) else acc
        val newBase = Integer.multiply(currentBase, currentBase)
        val newExp = shiftRight(exp)
        loop(newBase, newExp, newAcc)
    }
    loop(base.toInteger, exponent, Integer.fromInt(1))
  }
  
  /** 自然数を1ビット右シフト */
  private def shiftRight(n: Natural): Natural = n match {
    case Natural.Zero => Natural.Zero
    case Natural.Positive(bits) =>
      val bitsList = bits.toList
      bitsList match {
        case List(_) => Natural.Zero
        case _ :: tailBits =>
          if (tailBits.isEmpty) Natural.Zero
          else {
            val trimmed = tailBits.reverse.dropWhile(!_).reverse
            if (trimmed.isEmpty) Natural.Zero
            else NonEmptyList.fromList(trimmed) match {
              case Some(nel) => Natural.Positive(nel)
              case None => Natural.Zero
            }
          }
        case Nil => assert(false, "NonEmptyList cannot be empty"); Natural.Zero
      }
  }
  
  /** 比較（-1: a < b, 0: a == b, 1: a > b） */
  def compare(a: NonZeroInteger, b: NonZeroInteger): Int = (a, b) match {
    case (Positive(av), Positive(bv)) => Natural.compare(av, bv)
    case (Negative(av), Negative(bv)) => Natural.compare(bv, av)
    case (Positive(_), Negative(_)) => 1
    case (Negative(_), Positive(_)) => -1
  }
  
  /** 等価性 */
  def equal(a: NonZeroInteger, b: NonZeroInteger): Boolean = compare(a, b) == 0
  
  /** 絶対値 */
  def abs(a: NonZeroInteger): Natural.Positive = a.abs
}