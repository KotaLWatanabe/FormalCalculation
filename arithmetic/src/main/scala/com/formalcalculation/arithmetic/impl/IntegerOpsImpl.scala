// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic.impl

import com.formalcalculation.arithmetic.{Integer, IntegerOperations, Natural, NonZeroInteger}

/** Integer operations implementation */
class IntegerOpsImpl extends IntegerOperations {

  def fromNatural(n: Natural): Integer = Integer.fromNatural(n)

  def fromSignAndNatural(sign: com.formalcalculation.arithmetic.Sign, value: Natural): Integer = 
    Integer.fromSignAndNatural(sign, value)

  def fromInt(n: Int): Integer = Integer.fromInt(n)

  def add(a: Integer, b: Integer): Integer = (a.toOption, b.toOption) match {
    case (None, _) => b  // 0 + b = b
    case (_, None) => a  // a + 0 = a
    case (Some(nzA), Some(nzB)) => 
      NonZeroInteger.add(nzA, nzB)  // NonZeroInteger.add returns Integer
  }

  def subtract(a: Integer, b: Integer): Integer = add(a, negate(b))

  def negate(a: Integer): Integer = a.toOption match {
    case None => Integer.zero  // -0 = 0
    case Some(nz) => Integer.fromNonZero(NonZeroInteger.negate(nz))
  }

  def multiply(a: Integer, b: Integer): Integer = (a.toOption, b.toOption) match {
    case (None, _) | (_, None) => Integer.zero  // 0 * anything = 0
    case (Some(nzA), Some(nzB)) => 
      Integer.fromNonZero(NonZeroInteger.multiply(nzA, nzB))
  }

  def divideWithRemainder(dividend: Integer, divisor: Integer): Option[(Integer, Integer)] = 
    divisor.toOption match {
      case None => None  // ゼロ除算
      case Some(nzDivisor) => dividend.toOption match {
        case None => Some((Integer.zero, Integer.zero))  // 0 / nonzero = 0 remainder 0
        case Some(nzDividend) => 
          val (quotInt, remInt) = NonZeroInteger.divideWithRemainder(nzDividend, nzDivisor)
          Some((quotInt, remInt))
      }
    }

  def divide(a: Integer, b: Integer): Option[Integer] = 
    divideWithRemainder(a, b).map(_._1)

  def remainder(a: Integer, b: Integer): Option[Integer] = 
    divideWithRemainder(a, b).map(_._2)

  def power(base: Integer, exponent: Natural): Integer = 
    if (exponent.isZero) Integer.fromInt(1)
    else base.toOption match {
      case None => Integer.zero  // 0^n = 0 (for n > 0)
      case Some(nzBase) => NonZeroInteger.power(nzBase, exponent)
    }

  def compare(a: Integer, b: Integer): Int = (a.toOption, b.toOption) match {
    case (None, None) => 0  // 0 == 0
    case (None, Some(nzB)) => if (nzB.isPositive) -1 else 1  // 0 vs nonzero
    case (Some(nzA), None) => if (nzA.isPositive) 1 else -1  // nonzero vs 0
    case (Some(nzA), Some(nzB)) => NonZeroInteger.compare(nzA, nzB)
  }

  def equal(a: Integer, b: Integer): Boolean = compare(a, b) == 0

  def abs(a: Integer): Natural = a.abs

  // ヘルパーメソッドは不要（NonZeroIntegerに移譲）
}