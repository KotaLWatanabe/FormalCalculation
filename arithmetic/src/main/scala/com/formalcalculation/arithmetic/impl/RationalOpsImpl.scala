// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic
package impl

import com.formalcalculation.arithmetic.IntegerOps.Constants.*

import scala.annotation.tailrec

object RationalOpsImpl extends RationalOperations {

  def create(numerator: Integer, denominator: NonZeroInteger): Rational =
    RationalWrapper(numerator, denominator)

  def fromInteger(n: Integer): Rational =
    RationalWrapper(n, NonZeroOne)

  def fromInt(n: Int): Rational = fromInteger(Integer.fromInt(n))

  def add(a: Rational, b: Rational): Rational = {
    // a/b + c/d = (ad + bc) / (bd)
    val newNumerator = Integer.add(
      Integer.multiply(a.numerator, b.denominator.toInteger),
      Integer.multiply(b.numerator, a.denominator.toInteger)
    )
    val newDenominator = NonZeroInteger.multiply(a.denominator, b.denominator)
    reduce(RationalWrapper(newNumerator, newDenominator))
  }

  def subtract(a: Rational, b: Rational): Rational = add(a, negate(b))

  def negate(a: Rational): Rational =
    RationalWrapper(Integer.negate(a.numerator), a.denominator)

  def multiply(a: Rational, b: Rational): Rational = {
    // (a/b) * (c/d) = (ac) / (bd)
    val newNumerator   = Integer.multiply(a.numerator, b.numerator)
    val newDenominator = NonZeroInteger.multiply(a.denominator, b.denominator)
    reduce(RationalWrapper(newNumerator, newDenominator))
  }

  def divide(a: Rational, b: Rational): Option[Rational] = {
    if (b.isZero) None
    else reciprocal(b).map(multiply(a, _))
  }

  def reciprocal(a: Rational): Option[Rational] = {
    if (a.isZero) None
    else {
      NonZeroInteger.fromInteger(a.numerator) match {
        case Some(nonZeroNumerator) =>
          val newNumerator   = a.denominator.toInteger
          val newDenominator = nonZeroNumerator
          Some(reduce(RationalWrapper(newNumerator, newDenominator)))
        case None => None
      }
    }
  }

  def power(base: Rational, exponent: Integer): Option[Rational] = {
    if (exponent.isZero) Some(Rational.one)
    else if (exponent.isPositive) {
      // 正の指数の場合
      positiveIntegerPower(base, exponent.abs)
    } else {
      // 負の指数の場合: a^(-n) = (1/a)^n
      reciprocal(base).flatMap(positiveIntegerPower(_, exponent.abs))
    }
  }

  private def positiveIntegerPower(base: Rational, exponent: Natural): Option[Rational] = {
    if (exponent.isZero) Some(Rational.one)
    else if (exponent.isOne) Some(base)
    else {
      // 繰り返し二乗法を使用
      binaryPower(base, exponent)
    }
  }

  private def binaryPower(base: Rational, exponent: Natural): Option[Rational] = {
    @tailrec
    def loop(currentBase: Rational, exp: Natural, acc: Rational): Option[Rational] = {
      if (exp.isZero) Some(acc)
      else {
        val bits       = com.formalcalculation.arithmetic.impl.NaturalOpsImpl.getBits(exp)
        val newAcc     = if (bits.nonEmpty && bits.head) multiply(acc, currentBase) else acc
        val newBaseOpt = multiply(currentBase, currentBase)
        val newExp     = shiftRight(exp)
        loop(newBaseOpt, newExp, newAcc)
      }
    }
    loop(base, exponent, Rational.one)
  }

  /** 自然数の除算（商のみ） */
  private def quotientNatural(dividend: Natural, divisor: Natural): Natural = {
    require(!divisor.isZero, "Division by zero")
    if (dividend.isZero) Natural.zero
    else if (divisor.isOne) dividend
    else {
      @tailrec
      def loop(remainder: Natural, quotient: Natural): Natural = {
        if (Natural.compare(remainder, divisor) < 0) quotient
        else {
          val newRemainder = Natural.subtract(remainder, divisor).getOrElse(Natural.zero)
          val newQuotient  = Natural.add(quotient, NaturalOne)
          loop(newRemainder, newQuotient)
        }
      }
      loop(dividend, Natural.zero)
    }
  }

  /** 自然数を1ビット右シフト */
  private def shiftRight(n: Natural): Natural = {
    if (n.isZero) Natural.zero
    else {
      val bitsList = com.formalcalculation.arithmetic.impl.NaturalOpsImpl.getBits(n)
      bitsList match {
        case List(_) => Natural.zero
        case _ :: tailBits =>
          if (tailBits.isEmpty) Natural.zero
          else {
            val trimmed = tailBits.reverse.dropWhile(!_).reverse
            if (trimmed.isEmpty) Natural.zero
            else
              cats.data.NonEmptyList.fromList(trimmed) match {
                case Some(nel) => Natural.positiveFromBits(nel)
                case None      => Natural.zero
              }
          }
        case Nil => Natural.zero
      }
    }
  }

  def compare(a: Rational, b: Rational): Int = {
    // a/b と c/d を比較: ad と bc を比較
    val left  = Integer.multiply(a.numerator, b.denominator.toInteger)
    val right = Integer.multiply(b.numerator, a.denominator.toInteger)
    Integer.compare(left, right)
  }

  def equal(a: Rational, b: Rational): Boolean = compare(a, b) == 0

  def abs(a: Rational): Rational = {
    if (a.isNegative) negate(a) else a
  }

  def reduce(a: Rational): Rational = {
    if (a.isZero) RationalWrapper(Integer.zero, NonZeroOne)
    else {
      // 符号の正規化：分母を常に正にする
      val normalizedRational = if (a.denominator.isNegative) {
        RationalWrapper(Integer.negate(a.numerator), NonZeroInteger.negate(a.denominator))
      } else a

      val gcdValue = NumberTheory.gcd(Integer.abs(normalizedRational.numerator), normalizedRational.denominator.abs)
      if (gcdValue.isOne) {
        normalizedRational
      } else {
        // 実際の約分を実行
        val gcdInteger = Integer.fromNatural(gcdValue)
        val reducedNumerator =
          Integer.divide(normalizedRational.numerator, gcdInteger).getOrElse(normalizedRational.numerator)
        val reducedDenominatorInteger = Integer
          .divide(normalizedRational.denominator.toInteger, gcdInteger)
          .getOrElse(normalizedRational.denominator.toInteger)

        // NonZeroIntegerに変換
        NonZeroInteger.fromInteger(reducedDenominatorInteger) match {
          case Some(reducedDenominator) => RationalWrapper(reducedNumerator, reducedDenominator)
          case None                     => normalizedRational // 変換に失敗した場合は元の値を返す
        }
      }
    }
  }

  def rationalToString(r: Rational): String = {
    if (r.isZero) "0"
    else if (Integer.equal(Integer.fromNatural(r.denominator.abs), One)) {
      // 整数の場合
      IntegerOps.integerToString(r.numerator)
    } else {
      // 分数の場合
      s"${IntegerOps.integerToString(r.numerator)}/${IntegerOps.integerToString(r.denominator.toInteger)}"
    }
  }

  def integerPart(r: Rational): Integer = {
    if (r.isZero) Integer.zero
    else {
      Integer.divide(r.numerator, r.denominator.toInteger).getOrElse(Integer.zero)
    }
  }

  def fractionalPart(r: Rational): Rational = {
    // fractional part = r - floor(r)
    subtract(r, fromInteger(integerPart(r)))
  }
}
