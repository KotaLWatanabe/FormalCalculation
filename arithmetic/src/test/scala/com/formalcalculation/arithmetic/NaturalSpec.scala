// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import org.scalatestplus.scalacheck.ScalaCheckPropertyChecks
import com.formalcalculation.algebra.Monoid
import org.scalacheck.Gen
import cats.data.NonEmptyList

class NaturalSpec extends AnyFlatSpec with Matchers with ScalaCheckPropertyChecks {
  
  "Natural.fromInt" should "create correct natural numbers" in {
    Natural.fromInt(0) shouldBe Natural.Zero
    Natural.fromInt(1) shouldBe Natural.Positive(NonEmptyList.of(true))
    Natural.fromInt(2) shouldBe Natural.Positive(NonEmptyList.of(false, true))
    Natural.fromInt(3) shouldBe Natural.Positive(NonEmptyList.of(true, true))
    Natural.fromInt(4) shouldBe Natural.Positive(NonEmptyList.of(false, false, true))
    Natural.fromInt(5) shouldBe Natural.Positive(NonEmptyList.of(true, false, true))
  }
  
  it should "reject negative integers" in {
    an[IllegalArgumentException] should be thrownBy Natural.fromInt(-1)
  }
  
  "Natural addition" should "work correctly" in {
    val zero = Natural.Zero
    val one = Natural.fromInt(1)
    val two = Natural.fromInt(2)
    val three = Natural.fromInt(3)
    val five = Natural.fromInt(5)
    
    Natural.add(zero, zero) shouldBe zero
    Natural.add(zero, one) shouldBe one
    Natural.add(one, zero) shouldBe one
    Natural.add(one, one) shouldBe two
    Natural.add(two, three) shouldBe five
    Natural.add(three, two) shouldBe five
  }
  
  "Natural multiplication" should "work correctly" in {
    val zero = Natural.Zero
    val one = Natural.fromInt(1)
    val two = Natural.fromInt(2)
    val three = Natural.fromInt(3)
    val six = Natural.fromInt(6)
    val twelve = Natural.fromInt(12)
    
    Natural.multiply(zero, zero) shouldBe zero
    Natural.multiply(zero, one) shouldBe zero
    Natural.multiply(one, zero) shouldBe zero
    Natural.multiply(one, one) shouldBe one
    Natural.multiply(two, three) shouldBe six
    Natural.multiply(three, two) shouldBe six
    Natural.multiply(six, two) shouldBe twelve
  }
  
  "Natural comparison" should "work correctly" in {
    val zero = Natural.Zero
    val one = Natural.fromInt(1)
    val two = Natural.fromInt(2)
    val five = Natural.fromInt(5)
    val ten = Natural.fromInt(10)
    
    Natural.compare(zero, zero) shouldBe 0
    Natural.compare(one, one) shouldBe 0
    Natural.compare(zero, one) shouldBe -1
    Natural.compare(one, zero) shouldBe 1
    Natural.compare(two, five) shouldBe -1
    Natural.compare(five, two) shouldBe 1
    Natural.compare(ten, five) shouldBe 1
    Natural.compare(five, ten) shouldBe -1
  }
  
  "Natural subtraction" should "work correctly when result is non-negative" in {
    val zero = Natural.Zero
    val one = Natural.fromInt(1)
    val two = Natural.fromInt(2)
    val five = Natural.fromInt(5)
    val ten = Natural.fromInt(10)
    
    Natural.subtract(zero, zero) shouldBe Some(zero)
    Natural.subtract(one, one) shouldBe Some(zero)
    Natural.subtract(five, two) shouldBe Some(Natural.fromInt(3))
    Natural.subtract(ten, five) shouldBe Some(five)
    Natural.subtract(ten, ten) shouldBe Some(zero)
  }
  
  it should "return None when result would be negative" in {
    val zero = Natural.Zero
    val one = Natural.fromInt(1)
    val two = Natural.fromInt(2)
    val five = Natural.fromInt(5)
    
    Natural.subtract(zero, one) shouldBe None
    Natural.subtract(two, five) shouldBe None
    Natural.subtract(one, two) shouldBe None
  }
  
  "Natural equality" should "work correctly" in {
    val zero1 = Natural.Zero
    val zero2 = Natural.Zero
    val one1 = Natural.fromInt(1)
    val one2 = Natural.fromInt(1)
    val two = Natural.fromInt(2)
    
    Natural.equal(zero1, zero2) shouldBe true
    Natural.equal(one1, one2) shouldBe true
    Natural.equal(zero1, one1) shouldBe false
    Natural.equal(one1, two) shouldBe false
  }
  
  "Natural properties" should "satisfy basic arithmetic properties" in {
    forAll { (a: Int, b: Int, c: Int) =>
      whenever(a >= 0 && b >= 0 && c >= 0) {
        val natA = Natural.fromInt(a)
        val natB = Natural.fromInt(b)
        val natC = Natural.fromInt(c)
        
        // 加法の交換法則
        Natural.equal(
          Natural.add(natA, natB),
          Natural.add(natB, natA)
        ) shouldBe true
        
        // 加法の結合法則
        Natural.equal(
          Natural.add(Natural.add(natA, natB), natC),
          Natural.add(natA, Natural.add(natB, natC))
        ) shouldBe true
        
        // 乗法の交換法則
        Natural.equal(
          Natural.multiply(natA, natB),
          Natural.multiply(natB, natA)
        ) shouldBe true
        
        // 乗法の結合法則
        Natural.equal(
          Natural.multiply(Natural.multiply(natA, natB), natC),
          Natural.multiply(natA, Natural.multiply(natB, natC))
        ) shouldBe true
        
        // 分配法則
        Natural.equal(
          Natural.multiply(natA, Natural.add(natB, natC)),
          Natural.add(Natural.multiply(natA, natB), Natural.multiply(natA, natC))
        ) shouldBe true
        
        // 加法の単位元
        Natural.equal(Natural.add(natA, Natural.Zero), natA) shouldBe true
        
        // 乗法の単位元
        Natural.equal(Natural.multiply(natA, Natural.fromInt(1)), natA) shouldBe true
        
        // 乗法の零元
        Natural.equal(Natural.multiply(natA, Natural.Zero), Natural.Zero) shouldBe true
      }
    }
  }
  
  "Natural Addition Monoid" should "satisfy monoid laws" in {
    forAll(Gen.choose(0, 100), Gen.choose(0, 100), Gen.choose(0, 100)) { (a: Int, b: Int, c: Int) =>
      val natA = Natural.fromInt(a)
      val natB = Natural.fromInt(b) 
      val natC = Natural.fromInt(c)
      
      // Left identity - using Natural instances directly as Monoids
      natA.combine(natA.empty, natA) shouldBe natA
      
      // Right identity
      natA.combine(natA, natA.empty) shouldBe natA
      
      // Associativity
      natA.combine(natA.combine(natA, natB), natC) shouldBe
        natA.combine(natA, natA.combine(natB, natC))
    }
  }
  
  "Natural Multiplication Monoid" should "satisfy monoid laws" in {
    import Natural.naturalMultiplicationMonoid
    
    forAll(Gen.choose(0, 20), Gen.choose(0, 20), Gen.choose(0, 20)) { (a: Int, b: Int, c: Int) =>
      val natA = Natural.fromInt(a)
      val natB = Natural.fromInt(b)
      val natC = Natural.fromInt(c)
      
      // Left identity
      naturalMultiplicationMonoid.combine(naturalMultiplicationMonoid.empty, natA) shouldBe natA
      
      // Right identity  
      naturalMultiplicationMonoid.combine(natA, naturalMultiplicationMonoid.empty) shouldBe natA
      
      // Associativity
      naturalMultiplicationMonoid.combine(naturalMultiplicationMonoid.combine(natA, natB), natC) shouldBe
        naturalMultiplicationMonoid.combine(natA, naturalMultiplicationMonoid.combine(natB, natC))
    }
  }
  
  "Natural combineAll" should "work correctly" in {
    import com.formalcalculation.algebra.Monoid.*
    
    val numbers = List(Natural.fromInt(1), Natural.fromInt(2), Natural.fromInt(3), Natural.fromInt(4))
    numbers.combineAll shouldBe Natural.fromInt(10)
    
    List.empty[Natural].combineAll shouldBe Natural.Zero
  }
}