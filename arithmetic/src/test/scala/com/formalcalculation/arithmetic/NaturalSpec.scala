// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import cats.data.NonEmptyList
import org.scalacheck.Gen
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import org.scalatestplus.scalacheck.ScalaCheckPropertyChecks

class NaturalSpec extends AnyFlatSpec with Matchers with ScalaCheckPropertyChecks {

  "Natural.fromInt" should "create correct natural numbers" in {
    val _ = Natural.fromInt(0).shouldBe(Natural.Zero)
    val _ = Natural.fromInt(1).shouldBe(Natural.Positive(NonEmptyList.of(true)))
    val _ = Natural.fromInt(2).shouldBe(Natural.Positive(NonEmptyList.of(false, true)))
    val _ = Natural.fromInt(3).shouldBe(Natural.Positive(NonEmptyList.of(true, true)))
    val _ = Natural.fromInt(4).shouldBe(Natural.Positive(NonEmptyList.of(false, false, true)))
    val _ = Natural.fromInt(5).shouldBe(Natural.Positive(NonEmptyList.of(true, false, true)))
  }

  it should "reject negative integers" in {
    an[IllegalArgumentException] should be thrownBy Natural.fromInt(-1)
  }

  "Natural addition" should "work correctly" in {
    val zero  = Natural.Zero
    val one   = Natural.fromInt(1)
    val two   = Natural.fromInt(2)
    val three = Natural.fromInt(3)
    val five  = Natural.fromInt(5)

    val _ = Natural.add(zero, zero).shouldBe(zero)
    val _ = Natural.add(zero, one).shouldBe(one)
    val _ = Natural.add(one, zero).shouldBe(one)
    val _ = Natural.add(one, one).shouldBe(two)
    val _ = Natural.add(two, three).shouldBe(five)
    val _ = Natural.add(three, two).shouldBe(five)
  }

  "Natural multiplication" should "work correctly" in {
    val zero   = Natural.Zero
    val one    = Natural.fromInt(1)
    val two    = Natural.fromInt(2)
    val three  = Natural.fromInt(3)
    val six    = Natural.fromInt(6)
    val twelve = Natural.fromInt(12)

    val _ = Natural.multiply(zero, zero).shouldBe(zero)
    val _ = Natural.multiply(zero, one).shouldBe(zero)
    val _ = Natural.multiply(one, zero).shouldBe(zero)
    val _ = Natural.multiply(one, one).shouldBe(one)
    val _ = Natural.multiply(two, three).shouldBe(six)
    val _ = Natural.multiply(three, two).shouldBe(six)
    val _ = Natural.multiply(six, two).shouldBe(twelve)
  }

  "Natural comparison" should "work correctly" in {
    val zero = Natural.Zero
    val one  = Natural.fromInt(1)
    val two  = Natural.fromInt(2)
    val five = Natural.fromInt(5)
    val ten  = Natural.fromInt(10)

    val _ = Natural.compare(zero, zero).shouldBe(0)
    val _ = Natural.compare(one, one).shouldBe(0)
    val _ = Natural.compare(zero, one).shouldBe(-1)
    val _ = Natural.compare(one, zero).shouldBe(1)
    val _ = Natural.compare(two, five).shouldBe(-1)
    val _ = Natural.compare(five, two).shouldBe(1)
    val _ = Natural.compare(ten, five).shouldBe(1)
    val _ = Natural.compare(five, ten).shouldBe(-1)
  }

  "Natural subtraction" should "work correctly when result is non-negative" in {
    val zero = Natural.Zero
    val one  = Natural.fromInt(1)
    val two  = Natural.fromInt(2)
    val five = Natural.fromInt(5)
    val ten  = Natural.fromInt(10)

    val _ = Natural.subtract(zero, zero).shouldBe(Some(zero))
    val _ = Natural.subtract(one, one).shouldBe(Some(zero))
    val _ = Natural.subtract(five, two).shouldBe(Some(Natural.fromInt(3)))
    val _ = Natural.subtract(ten, five).shouldBe(Some(five))
    val _ = Natural.subtract(ten, ten).shouldBe(Some(zero))
  }

  it should "return None when result would be negative" in {
    val zero = Natural.Zero
    val one  = Natural.fromInt(1)
    val two  = Natural.fromInt(2)
    val five = Natural.fromInt(5)

    val _ = Natural.subtract(zero, one).shouldBe(None)
    val _ = Natural.subtract(two, five).shouldBe(None)
    val _ = Natural.subtract(one, two).shouldBe(None)
  }

  "Natural equality" should "work correctly" in {
    val zero1 = Natural.Zero
    val zero2 = Natural.Zero
    val one1  = Natural.fromInt(1)
    val one2  = Natural.fromInt(1)
    val two   = Natural.fromInt(2)

    val _ = Natural.equal(zero1, zero2).shouldBe(true)
    val _ = Natural.equal(one1, one2).shouldBe(true)
    val _ = Natural.equal(zero1, one1).shouldBe(false)
    val _ = Natural.equal(one1, two).shouldBe(false)
  }

  "Natural properties" should "satisfy basic arithmetic properties" in {
    import org.scalacheck.Gen
    val nonNegInt = Gen.choose(0, 1000)
    forAll(nonNegInt, nonNegInt, nonNegInt) { (a: Int, b: Int, c: Int) =>
      val natA = Natural.fromInt(a)
      val natB = Natural.fromInt(b)
      val natC = Natural.fromInt(c)

      // 加法の交換法則
      val _ = Natural
        .equal(
          Natural.add(natA, natB),
          Natural.add(natB, natA)
        )
        .shouldBe(true)

      // 加法の結合法則
      val _ = Natural
        .equal(
          Natural.add(Natural.add(natA, natB), natC),
          Natural.add(natA, Natural.add(natB, natC))
        )
        .shouldBe(true)

      // 乗法の交換法則
      val _ = Natural
        .equal(
          Natural.multiply(natA, natB),
          Natural.multiply(natB, natA)
        )
        .shouldBe(true)

      // 乗法の結合法則
      val _ = Natural
        .equal(
          Natural.multiply(Natural.multiply(natA, natB), natC),
          Natural.multiply(natA, Natural.multiply(natB, natC))
        )
        .shouldBe(true)

      // 分配法則
      val _ = Natural
        .equal(
          Natural.multiply(natA, Natural.add(natB, natC)),
          Natural.add(Natural.multiply(natA, natB), Natural.multiply(natA, natC))
        )
        .shouldBe(true)

      // 加法の単位元
      val _ = Natural.equal(Natural.add(natA, Natural.Zero), natA).shouldBe(true)

      // 乗法の単位元
      val _ = Natural.equal(Natural.multiply(natA, Natural.fromInt(1)), natA).shouldBe(true)

      // 乗法の零元
      val _ = Natural.equal(Natural.multiply(natA, Natural.Zero), Natural.Zero).shouldBe(true)
    }
  }

  "Natural Addition Monoid" should "satisfy monoid laws" in {
    import Natural.naturalAdditionMonoid
    forAll(Gen.choose(0, 100), Gen.choose(0, 100), Gen.choose(0, 100)) { (a: Int, b: Int, c: Int) =>
      val natA = Natural.fromInt(a)
      val natB = Natural.fromInt(b)
      val natC = Natural.fromInt(c)

      // Left identity - using explicit monoid instance
      val _ = naturalAdditionMonoid.combine(naturalAdditionMonoid.empty, natA).shouldBe(natA)

      // Right identity
      val _ = naturalAdditionMonoid.combine(natA, naturalAdditionMonoid.empty).shouldBe(natA)

      // Associativity
      val _ = naturalAdditionMonoid
        .combine(naturalAdditionMonoid.combine(natA, natB), natC)
        .shouldBe(naturalAdditionMonoid.combine(natA, naturalAdditionMonoid.combine(natB, natC)))
    }
  }

  "Natural Multiplication Monoid" should "satisfy monoid laws" in {
    import Natural.naturalMultiplicationMonoid

    forAll(Gen.choose(0, 20), Gen.choose(0, 20), Gen.choose(0, 20)) { (a: Int, b: Int, c: Int) =>
      val natA = Natural.fromInt(a)
      val natB = Natural.fromInt(b)
      val natC = Natural.fromInt(c)

      // Left identity
      val _ = naturalMultiplicationMonoid.combine(naturalMultiplicationMonoid.empty, natA).shouldBe(natA)

      // Right identity
      val _ = naturalMultiplicationMonoid.combine(natA, naturalMultiplicationMonoid.empty).shouldBe(natA)

      // Associativity
      val _ = naturalMultiplicationMonoid
        .combine(naturalMultiplicationMonoid.combine(natA, natB), natC)
        .shouldBe(naturalMultiplicationMonoid.combine(natA, naturalMultiplicationMonoid.combine(natB, natC)))
    }
  }

  "Natural combineAll" should "work correctly" in {
    import Natural.naturalAdditionMonoid

    val numbers: List[Natural] = List(Natural.fromInt(1), Natural.fromInt(2), Natural.fromInt(3), Natural.fromInt(4))
    val _ = naturalAdditionMonoid.combineAll(numbers).shouldBe(Natural.fromInt(10))

    val _ = naturalAdditionMonoid.combineAll(List.empty[Natural]).shouldBe(Natural.Zero)
  }
}
