// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers

class NumberTheorySpec extends AnyFlatSpec with Matchers {

  "GCD" should "work correctly for natural numbers" in {
    val zero     = Natural.Zero
    val one      = Natural.fromInt(1)
    val two      = Natural.fromInt(2)
    val three    = Natural.fromInt(3)
    val four     = Natural.fromInt(4)
    val six      = Natural.fromInt(6)
    val eight    = Natural.fromInt(8)
    val twelve   = Natural.fromInt(12)
    val fifteen  = Natural.fromInt(15)
    val eighteen = Natural.fromInt(18)

    val _ = NumberTheory.gcd(zero, zero).shouldBe(zero)
    val _ = NumberTheory.gcd(zero, one).shouldBe(one)
    val _ = NumberTheory.gcd(one, zero).shouldBe(one)
    val _ = NumberTheory.gcd(one, one).shouldBe(one)
    val _ = NumberTheory.gcd(two, three).shouldBe(one)
    val _ = NumberTheory.gcd(four, six).shouldBe(two)
    val _ = NumberTheory.gcd(eight, twelve).shouldBe(four)
    val _ = NumberTheory.gcd(fifteen, eighteen).shouldBe(three)
  }

  "LCM" should "work correctly for natural numbers" in {
    val zero    = Natural.Zero
    val one     = Natural.fromInt(1)
    val two     = Natural.fromInt(2)
    val three   = Natural.fromInt(3)
    val four    = Natural.fromInt(4)
    val six     = Natural.fromInt(6)
    val twelve  = Natural.fromInt(12)
    val fifteen = Natural.fromInt(15)
    val thirty  = Natural.fromInt(30)

    val _ = NumberTheory.lcm(zero, zero).shouldBe(zero)
    val _ = NumberTheory.lcm(zero, one).shouldBe(zero)
    val _ = NumberTheory.lcm(one, zero).shouldBe(zero)
    val _ = NumberTheory.lcm(one, one).shouldBe(one)
    val _ = NumberTheory.lcm(two, three).shouldBe(six)
    val _ = NumberTheory.lcm(four, six).shouldBe(twelve)
    val _ = NumberTheory.lcm(six, fifteen).shouldBe(thirty)
  }

  "Even/Odd detection" should "work correctly" in {
    val zero  = Natural.Zero
    val one   = Natural.fromInt(1)
    val two   = Natural.fromInt(2)
    val three = Natural.fromInt(3)
    val four  = Natural.fromInt(4)
    val five  = Natural.fromInt(5)

    val _ = NumberTheory.isEven(zero).shouldBe(true)
    val _ = NumberTheory.isEven(one).shouldBe(false)
    val _ = NumberTheory.isEven(two).shouldBe(true)
    val _ = NumberTheory.isEven(three).shouldBe(false)
    val _ = NumberTheory.isEven(four).shouldBe(true)
    val _ = NumberTheory.isEven(five).shouldBe(false)

    val _ = NumberTheory.isOdd(zero).shouldBe(false)
    val _ = NumberTheory.isOdd(one).shouldBe(true)
    val _ = NumberTheory.isOdd(two).shouldBe(false)
    val _ = NumberTheory.isOdd(three).shouldBe(true)
    val _ = NumberTheory.isOdd(four).shouldBe(false)
    val _ = NumberTheory.isOdd(five).shouldBe(true)
  }

  "Divisibility" should "work correctly" in {
    val zero   = Natural.Zero
    val one    = Natural.fromInt(1)
    val two    = Natural.fromInt(2)
    val three  = Natural.fromInt(3)
    val four   = Natural.fromInt(4)
    val six    = Natural.fromInt(6)
    val eight  = Natural.fromInt(8)
    val nine   = Natural.fromInt(9)
    val twelve = Natural.fromInt(12)

    val _ = NumberTheory.isDivisibleBy(zero, one).shouldBe(true)
    val _ = NumberTheory.isDivisibleBy(zero, two).shouldBe(true)
    val _ = NumberTheory.isDivisibleBy(one, zero).shouldBe(false) // ゼロ除算

    val _ = NumberTheory.isDivisibleBy(four, two).shouldBe(true)
    val _ = NumberTheory.isDivisibleBy(six, three).shouldBe(true)
    val _ = NumberTheory.isDivisibleBy(eight, four).shouldBe(true)
    val _ = NumberTheory.isDivisibleBy(twelve, three).shouldBe(true)
    val _ = NumberTheory.isDivisibleBy(twelve, four).shouldBe(true)

    val _ = NumberTheory.isDivisibleBy(three, two).shouldBe(false)
    val _ = NumberTheory.isDivisibleBy(four, three).shouldBe(false)
    val _ = NumberTheory.isDivisibleBy(nine, four).shouldBe(false)
  }

  "Prime detection" should "work correctly for small numbers" in {
    val zero     = Natural.Zero
    val one      = Natural.fromInt(1)
    val two      = Natural.fromInt(2)
    val three    = Natural.fromInt(3)
    val four     = Natural.fromInt(4)
    val five     = Natural.fromInt(5)
    val six      = Natural.fromInt(6)
    val seven    = Natural.fromInt(7)
    val eight    = Natural.fromInt(8)
    val nine     = Natural.fromInt(9)
    val ten      = Natural.fromInt(10)
    val eleven   = Natural.fromInt(11)
    val twelve   = Natural.fromInt(12)
    val thirteen = Natural.fromInt(13)

    val _ = NumberTheory.isPrime(zero).shouldBe(false)
    val _ = NumberTheory.isPrime(one).shouldBe(false)
    val _ = NumberTheory.isPrime(two).shouldBe(true)
    val _ = NumberTheory.isPrime(three).shouldBe(true)
    val _ = NumberTheory.isPrime(four).shouldBe(false)
    val _ = NumberTheory.isPrime(five).shouldBe(true)
    val _ = NumberTheory.isPrime(six).shouldBe(false)
    val _ = NumberTheory.isPrime(seven).shouldBe(true)
    val _ = NumberTheory.isPrime(eight).shouldBe(false)
    val _ = NumberTheory.isPrime(nine).shouldBe(false)
    val _ = NumberTheory.isPrime(ten).shouldBe(false)
    val _ = NumberTheory.isPrime(eleven).shouldBe(true)
    val _ = NumberTheory.isPrime(twelve).shouldBe(false)
    val _ = NumberTheory.isPrime(thirteen).shouldBe(true)
  }

  "Factorial" should "work correctly" in {
    val zero  = Natural.Zero
    val one   = Natural.fromInt(1)
    val two   = Natural.fromInt(2)
    val three = Natural.fromInt(3)
    val four  = Natural.fromInt(4)
    val five  = Natural.fromInt(5)

    val _ = NumberTheory.factorial(zero).shouldBe(one)                  // 0! = 1
    val _ = NumberTheory.factorial(one).shouldBe(one)                   // 1! = 1
    val _ = NumberTheory.factorial(two).shouldBe(two)                   // 2! = 2
    val _ = NumberTheory.factorial(three).shouldBe(Natural.fromInt(6))  // 3! = 6
    val _ = NumberTheory.factorial(four).shouldBe(Natural.fromInt(24))  // 4! = 24
    val _ = NumberTheory.factorial(five).shouldBe(Natural.fromInt(120)) // 5! = 120
  }

  "Fibonacci" should "work correctly" in {
    val zero  = Natural.Zero
    val one   = Natural.fromInt(1)
    val two   = Natural.fromInt(2)
    val three = Natural.fromInt(3)
    val four  = Natural.fromInt(4)
    val five  = Natural.fromInt(5)
    val six   = Natural.fromInt(6)
    val seven = Natural.fromInt(7)
    val eight = Natural.fromInt(8)

    val _ = NumberTheory.fibonacci(zero).shouldBe(zero)                 // F(0) = 0
    val _ = NumberTheory.fibonacci(one).shouldBe(one)                   // F(1) = 1
    val _ = NumberTheory.fibonacci(two).shouldBe(one)                   // F(2) = 1
    val _ = NumberTheory.fibonacci(three).shouldBe(two)                 // F(3) = 2
    val _ = NumberTheory.fibonacci(four).shouldBe(three)                // F(4) = 3
    val _ = NumberTheory.fibonacci(five).shouldBe(five)                 // F(5) = 5
    val _ = NumberTheory.fibonacci(six).shouldBe(eight)                 // F(6) = 8
    val _ = NumberTheory.fibonacci(seven).shouldBe(Natural.fromInt(13)) // F(7) = 13
    val _ = NumberTheory.fibonacci(eight).shouldBe(Natural.fromInt(21)) // F(8) = 21
  }

  "Binomial coefficient" should "work correctly" in {
    val zero  = Natural.Zero
    val one   = Natural.fromInt(1)
    val two   = Natural.fromInt(2)
    val three = Natural.fromInt(3)
    val four  = Natural.fromInt(4)
    val five  = Natural.fromInt(5)

    // C(n, 0) = 1
    val _ = NumberTheory.binomialCoefficient(zero, zero).shouldBe(Some(one))
    val _ = NumberTheory.binomialCoefficient(one, zero).shouldBe(Some(one))
    val _ = NumberTheory.binomialCoefficient(five, zero).shouldBe(Some(one))

    // C(n, n) = 1
    val _ = NumberTheory.binomialCoefficient(one, one).shouldBe(Some(one))
    val _ = NumberTheory.binomialCoefficient(three, three).shouldBe(Some(one))
    val _ = NumberTheory.binomialCoefficient(five, five).shouldBe(Some(one))

    // C(n, 1) = n
    val _ = NumberTheory.binomialCoefficient(one, one).shouldBe(Some(one))
    val _ = NumberTheory.binomialCoefficient(three, one).shouldBe(Some(three))
    val _ = NumberTheory.binomialCoefficient(five, one).shouldBe(Some(five))

    // その他の組み合わせ
    val _ = NumberTheory.binomialCoefficient(four, two).shouldBe(Some(Natural.fromInt(6)))    // C(4,2) = 6
    val _ = NumberTheory.binomialCoefficient(five, two).shouldBe(Some(Natural.fromInt(10)))   // C(5,2) = 10
    val _ = NumberTheory.binomialCoefficient(five, three).shouldBe(Some(Natural.fromInt(10))) // C(5,3) = 10

    // k > n の場合は 0
    val _ = NumberTheory.binomialCoefficient(three, four).shouldBe(Some(zero))
    val _ = NumberTheory.binomialCoefficient(two, five).shouldBe(Some(zero))
  }

  "GCD and LCM relationship" should "satisfy fundamental properties" in {
    val a             = Natural.fromInt(12)
    val b             = Natural.fromInt(18)
    val gcdValue      = NumberTheory.gcd(a, b)
    val lcmValue      = NumberTheory.lcm(a, b)
    val product       = Natural.multiply(a, b)
    val gcdLcmProduct = Natural.multiply(gcdValue, lcmValue)

    // gcd(a,b) * lcm(a,b) = a * b
    val _ = Natural.equal(gcdLcmProduct, product).shouldBe(true)
  }
}
