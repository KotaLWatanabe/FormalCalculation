// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import IntegerOps.*
import com.formalcalculation.arithmetic.IntegerOps.Constants.*

class IntegerOpsSpec extends AnyFlatSpec with Matchers {

  "Natural operators" should "work correctly with explicit method calls" in {
    val one   = Natural.fromInt(1)
    val two   = Natural.fromInt(2)
    val three = Natural.fromInt(3)
    val five  = Natural.fromInt(5)

    // 加算
    val _ = Natural.add(one, two).shouldBe(three)
    val _ = Natural.add(two, three).shouldBe(five)

    // 乗算
    val _ = Natural.multiply(two, three).shouldBe(Natural.fromInt(6))
    val _ = Natural.multiply(one, five).shouldBe(five)

    // 減算
    val _ = Natural.subtract(five, two).shouldBe(Some(three))
    val _ = Natural.subtract(two, five).shouldBe(None)

    // 比較
    val _ = Natural.equal(one, one).shouldBe(true)
    val _ = (!Natural.equal(one, two)).shouldBe(true)
    val _ = (Natural.compare(one, two) < 0).shouldBe(true)
    val _ = (Natural.compare(two, one) > 0).shouldBe(true)
    val _ = (Natural.compare(one, one) <= 0).shouldBe(true)
    val _ = (Natural.compare(two, one) >= 0).shouldBe(true)
  }

  "Integer operators" should "work correctly with explicit method calls" in {
    val zero     = Integer.zero
    val one      = Integer.fromInt(1)
    val minusOne = Integer.fromInt(-1)
    val two      = Integer.fromInt(2)
    val three    = Integer.fromInt(3)
    val five     = Integer.fromInt(5)
    val six      = Integer.fromInt(6)
    val eight    = Integer.fromInt(8)

    // 加算
    val _ = Integer.add(one, two).shouldBe(three)
    val _ = Integer.add(one, minusOne).shouldBe(zero)

    // 減算
    val _ = Integer.subtract(five, two).shouldBe(three)
    val _ = Integer.subtract(two, five).shouldBe(Integer.fromInt(-3))

    // 乗算
    val _ = Integer.multiply(two, three).shouldBe(six)
    val _ = Integer.multiply(two, minusOne).shouldBe(Integer.fromInt(-2))

    // 除算
    val _ = Integer.divide(six, two).shouldBe(Some(three))
    val _ = Integer.divide(five, two).shouldBe(Some(two))
    val _ = Integer.divide(one, zero).shouldBe(None)

    // 余り
    val _ = Integer.remainder(five, two).shouldBe(Some(one))
    val _ = Integer.remainder(six, three).shouldBe(Some(zero))

    // べき乗
    val _ = Integer.power(two, Natural.fromInt(3)).shouldBe(eight)
    val _ = Integer.power(minusOne, Natural.fromInt(2)).shouldBe(one)

    // 単項マイナス
    val _ = Integer.negate(one).shouldBe(minusOne)
    val _ = Integer.negate(minusOne).shouldBe(one)
    val _ = Integer.negate(zero).shouldBe(zero)

    // 比較
    val _ = Integer.equal(one, one).shouldBe(true)
    val _ = (!Integer.equal(one, two)).shouldBe(true)
    val _ = (Integer.compare(one, two) < 0).shouldBe(true)
    val _ = (Integer.compare(two, one) > 0).shouldBe(true)
    val _ = (Integer.compare(minusOne, zero) < 0).shouldBe(true)
    val _ = (Integer.compare(zero, minusOne) > 0).shouldBe(true)

    // 絶対値
    val _ = Integer.abs(one).shouldBe(Natural.fromInt(1))
    val _ = Integer.abs(minusOne).shouldBe(Natural.fromInt(1))
    val _ = Integer.abs(zero).shouldBe(Natural.zero)
  }

  "Explicit conversions" should "work correctly" in {
    // Int から Integer への変換
    val intOne: Integer      = IntegerOps.Conversions.intToInteger(1)
    val intMinusOne: Integer = IntegerOps.Conversions.intToInteger(-1)
    val intZero: Integer     = IntegerOps.Conversions.intToInteger(0)

    val _ = intOne.shouldBe(Integer.fromInt(1))
    val _ = intMinusOne.shouldBe(Integer.fromInt(-1))
    val _ = intZero.shouldBe(Integer.zero)

    // Int から Natural への変換（非負の場合）
    val natOne: Natural  = IntegerOps.Conversions.intToNatural(1)
    val natTwo: Natural  = IntegerOps.Conversions.intToNatural(2)
    val natZero: Natural = IntegerOps.Conversions.intToNatural(0)

    val _ = natOne.shouldBe(Natural.fromInt(1))
    val _ = natTwo.shouldBe(Natural.fromInt(2))
    val _ = natZero.shouldBe(Natural.zero)

    // 負数は変換できない
    an[IllegalArgumentException] should be thrownBy {
      IntegerOps.Conversions.intToNatural(-1)
    }
  }

  "Constants" should "be accessible" in {
    val _ = Zero.shouldBe(Integer.zero)
    val _ = One.shouldBe(Integer.fromInt(1))
    val _ = MinusOne.shouldBe(Integer.fromInt(-1))
    val _ = Two.shouldBe(Integer.fromInt(2))

    val _ = NaturalZero.shouldBe(Natural.zero)
    val _ = NaturalOne.shouldBe(Natural.fromInt(1))
    val _ = NaturalTwo.shouldBe(Natural.fromInt(2))
  }

  "Mixed operations" should "work with implicit conversions" in {
    // Integer と Int の混合演算
    val result1 = Integer.add(Integer.fromInt(5), Integer.fromInt(3))
    val _ = result1.shouldBe(Integer.fromInt(8))

    val result2 = Integer.subtract(Integer.fromInt(10), Integer.fromInt(4))
    val _ = result2.shouldBe(Integer.fromInt(6))

    val result3 = Integer.multiply(Integer.fromInt(3), Integer.fromInt(4))
    val _ = result3.shouldBe(Integer.fromInt(12))

    // Natural と Int の混合演算
    val result4 = Natural.add(Natural.fromInt(5), Natural.fromInt(3))
    val _ = result4.shouldBe(Natural.fromInt(8))

    val result5 = Natural.multiply(Natural.fromInt(3), Natural.fromInt(4))
    val _ = result5.shouldBe(Natural.fromInt(12))
  }

  "String representation" should "work correctly" in {
    // Natural の文字列表現
    val _ = Natural.zero.show.shouldBe("0")
    val _ = Natural.fromInt(1).show.shouldBe("1")
    val _ = Natural.fromInt(5).show.shouldBe("5")
    val _ = Natural.fromInt(10).show.shouldBe("10")
    val _ = Natural.fromInt(123).show.shouldBe("123")

    // Integer の文字列表現
    val _ = Integer.zero.show.shouldBe("0")
    val _ = Integer.fromInt(1).show.shouldBe("1")
    val _ = Integer.fromInt(-1).show.shouldBe("-1")
    val _ = Integer.fromInt(5).show.shouldBe("5")
    val _ = Integer.fromInt(-5).show.shouldBe("-5")
    val _ = Integer.fromInt(42).show.shouldBe("42")
    val _ = Integer.fromInt(-42).show.shouldBe("-42")
  }
}
