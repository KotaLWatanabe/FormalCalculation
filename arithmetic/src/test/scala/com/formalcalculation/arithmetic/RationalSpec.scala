// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.arithmetic

import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import org.scalacheck.{Arbitrary, Gen}
import org.scalatestplus.scalacheck.ScalaCheckPropertyChecks

class RationalSpec extends AnyFlatSpec with Matchers with ScalaCheckPropertyChecks {

  // テスト用の有理数生成
  implicit val arbRational: Arbitrary[Rational] = Arbitrary {
    for {
      num <- Gen.choose(-100, 100)
      den <- Gen.choose(1, 100)
    } yield Rational(Integer.fromInt(num), NonZeroInteger.fromIntUnsafe(den))
  }

  "Rational.apply" should "create a rational number with given numerator and denominator" in {
    val r = Rational(Integer.fromInt(3), NonZeroInteger.fromIntUnsafe(4))
    r.numerator shouldBe Integer.fromInt(3)
    r.denominator shouldBe NonZeroInteger.fromIntUnsafe(4)
  }

  it should "automatically reduce fractions" in {
    val r = Rational(Integer.fromInt(6), NonZeroInteger.fromIntUnsafe(8))
    // Already reduced once by Rational.apply, should be 3/4
    r.numerator shouldBe Integer.fromInt(3)
    r.denominator shouldBe NonZeroInteger.fromIntUnsafe(4)
  }

  "Rational.fromInteger" should "create a rational from an integer" in {
    val r = Rational.fromInteger(Integer.fromInt(5))
    r.numerator shouldBe Integer.fromInt(5)
    r.denominator shouldBe NonZeroInteger.fromIntUnsafe(1)
  }

  "Rational.fromInt" should "create a rational from an int" in {
    val r = Rational.fromInt(7)
    r.numerator shouldBe Integer.fromInt(7)
    r.denominator shouldBe NonZeroInteger.fromIntUnsafe(1)
  }

  "Rational arithmetic" should "add correctly" in {
    // 1/2 + 1/3 = 5/6
    val a = Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(2))
    val b = Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(3))
    val result = a + b
    result.numerator shouldBe Integer.fromInt(5)
    result.denominator shouldBe NonZeroInteger.fromIntUnsafe(6)
  }

  it should "subtract correctly" in {
    // 3/4 - 1/4 = 1/2
    val a = Rational(Integer.fromInt(3), NonZeroInteger.fromIntUnsafe(4))
    val b = Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(4))
    val result = a - b
    result.numerator shouldBe Integer.fromInt(1)
    result.denominator shouldBe NonZeroInteger.fromIntUnsafe(2)
  }

  it should "multiply correctly" in {
    // 2/3 * 3/4 = 1/2
    val a = Rational(Integer.fromInt(2), NonZeroInteger.fromIntUnsafe(3))
    val b = Rational(Integer.fromInt(3), NonZeroInteger.fromIntUnsafe(4))
    val result = a * b
    result.numerator shouldBe Integer.fromInt(1)
    result.denominator shouldBe NonZeroInteger.fromIntUnsafe(2)
  }

  it should "divide correctly" in {
    // (1/2) / (1/4) = 2
    val a = Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(2))
    val b = Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(4))
    val result = a / b
    result shouldBe Some(Rational.fromInt(2))
  }

  it should "handle division by zero" in {
    val a = Rational.fromInt(1)
    val zero = Rational.zero
    (a / zero) shouldBe None
  }

  "Rational comparison" should "compare correctly" in {
    val a = Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(2)) // 1/2
    val b = Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(3)) // 1/3
    
    a.compare(b) should be > 0
    b.compare(a) should be < 0
    a.compare(a) shouldBe 0
  }

  it should "test equality correctly" in {
    val a = Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(2))
    val b = Rational(Integer.fromInt(2), NonZeroInteger.fromIntUnsafe(4)) // equivalent to 1/2
    val c = Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(3))
    
    a.equal(b) shouldBe true
    a.equal(c) shouldBe false
  }

  "Rational properties" should "identify zero correctly" in {
    Rational.zero.isZero shouldBe true
    Rational.fromInt(5).isZero shouldBe false
  }

  it should "identify positive/negative correctly" in {
    val pos = Rational(Integer.fromInt(3), NonZeroInteger.fromIntUnsafe(4))
    val neg = Rational(Integer.fromInt(-3), NonZeroInteger.fromIntUnsafe(4))
    val zero = Rational.zero
    
    pos.isPositive shouldBe true
    pos.isNegative shouldBe false
    
    neg.isPositive shouldBe false
    neg.isNegative shouldBe true
    
    zero.isPositive shouldBe false
    zero.isNegative shouldBe false
  }

  it should "identify one correctly" in {
    Rational.one.isOne shouldBe true
    Rational(Integer.fromInt(4), NonZeroInteger.fromIntUnsafe(4)).isOne shouldBe true
    Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(2)).isOne shouldBe false
  }

  "Rational.reciprocal" should "calculate reciprocal correctly" in {
    val r = Rational(Integer.fromInt(3), NonZeroInteger.fromIntUnsafe(4))
    val recip = r.reciprocal
    recip shouldBe Some(Rational(Integer.fromInt(4), NonZeroInteger.fromIntUnsafe(3)))
  }

  it should "return None for zero" in {
    Rational.zero.reciprocal shouldBe None
  }

  "Rational.abs" should "calculate absolute value correctly" in {
    val pos = Rational(Integer.fromInt(3), NonZeroInteger.fromIntUnsafe(4))
    val neg = Rational(Integer.fromInt(-3), NonZeroInteger.fromIntUnsafe(4))
    
    pos.abs shouldBe pos
    neg.abs shouldBe pos
  }

  "Rational.power" should "calculate powers correctly" in {
    val r = Rational(Integer.fromInt(2), NonZeroInteger.fromIntUnsafe(3))
    
    // (2/3)^2 = 4/9
    val squared = r ** Integer.fromInt(2)
    squared shouldBe Some(Rational(Integer.fromInt(4), NonZeroInteger.fromIntUnsafe(9)))
    
    // (2/3)^0 = 1
    val zeroPower = r ** Integer.zero
    zeroPower shouldBe Some(Rational.one)
    
    // (2/3)^(-1) = 3/2
    val negativePower = r ** Integer.fromInt(-1)
    negativePower shouldBe Some(Rational(Integer.fromInt(3), NonZeroInteger.fromIntUnsafe(2)))
  }

  "Rational.integerPart" should "extract integer part correctly" in {
    val r1 = Rational(Integer.fromInt(7), NonZeroInteger.fromIntUnsafe(3)) // 7/3 = 2.333...
    r1.integerPart shouldBe Integer.fromInt(2)
    
    val r2 = Rational(Integer.fromInt(-7), NonZeroInteger.fromIntUnsafe(3)) // -7/3 = -2.333...
    r2.integerPart shouldBe Integer.fromInt(-2)
    
    val r3 = Rational(Integer.fromInt(1), NonZeroInteger.fromIntUnsafe(2)) // 1/2 = 0.5
    r3.integerPart shouldBe Integer.zero
  }

  "Rational string representation" should "display correctly" in {
    val r1 = Rational(Integer.fromInt(3), NonZeroInteger.fromIntUnsafe(4))
    r1.show shouldBe "3/4"
    
    val r2 = Rational.fromInt(5)
    r2.show shouldBe "5"
    
    val r3 = Rational.zero
    r3.show shouldBe "0"
    
    val r4 = Rational(Integer.fromInt(-3), NonZeroInteger.fromIntUnsafe(4))
    r4.show shouldBe "-3/4"
  }

  "Rational reduction" should "handle negative denominators correctly" in {
    // -3/-4 should become 3/4
    val r = Rational(Integer.fromInt(-3), NonZeroInteger.fromIntUnsafe(-4))
    val reduced = r.reduced
    reduced.numerator shouldBe Integer.fromInt(3)
    reduced.denominator shouldBe NonZeroInteger.fromIntUnsafe(4)
  }

  // Property-based tests
  "Rational operations" should "satisfy addition commutativity" in {
    forAll { (a: Rational, b: Rational) =>
      val _ = (a + b).equal(b + a).shouldBe(true)
    }
  }

  it should "satisfy addition associativity" in {
    forAll { (a: Rational, b: Rational, c: Rational) =>
      val _ = ((a + b) + c).equal(a + (b + c)).shouldBe(true)
    }
  }

  it should "have additive identity" in {
    forAll { (a: Rational) =>
      val _ = (a + Rational.zero).equal(a).shouldBe(true)
      val _ = (Rational.zero + a).equal(a).shouldBe(true)
    }
  }

  it should "satisfy multiplication commutativity" in {
    forAll { (a: Rational, b: Rational) =>
      val _ = (a * b).equal(b * a).shouldBe(true)
    }
  }

  it should "have multiplicative identity" in {
    forAll { (a: Rational) =>
      val _ = (a * Rational.one).equal(a).shouldBe(true)
      val _ = (Rational.one * a).equal(a).shouldBe(true)
    }
  }
}