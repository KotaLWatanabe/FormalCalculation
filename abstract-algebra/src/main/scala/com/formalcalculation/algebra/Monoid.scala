// Generated by Claude Sonnet 4 (claude-sonnet-4-20250514)
package com.formalcalculation.algebra

/**
 * Monoid: A semigroup with an identity element
 * 
 * Laws:
 * - Associativity: combine(combine(x, y), z) == combine(x, combine(y, z)) (inherited from Semigroup)
 * - Left identity: combine(empty, x) == x
 * - Right identity: combine(x, empty) == x
 */
trait Monoid[A] extends Semigroup[A] {
  def empty: A
  
  /** Fold a list using this monoid */
  def combineAll(xs: List[A]): A = xs.foldLeft(empty)(combine)
  
  /** Check if a value is the identity element */
  def isEmpty(a: A): Boolean = a == empty
}

object Monoid {
  def apply[A](using M: Monoid[A]): Monoid[A] = M
  
  /** Create a Monoid instance */
  def instance[A](emptyValue: A, combineFunction: (A, A) => A): Monoid[A] = 
    new Monoid[A] {
      def empty: A = emptyValue
      def combine(x: A, y: A): A = combineFunction(x, y)
    }

  extension [A](x: A)(using M: Monoid[A]) {
    /** Combine two values */
    def combine(y: A): A = M.combine(x, y)
  }
  /** Syntax extensions for Monoid operations */
  extension [A](xs: List[A])(using M: Monoid[A])
    def combineAll: A = M.combineAll(xs)
  
  // Basic monoid instances
  
  /** String monoid with concatenation */
  given stringMonoid: Monoid[String] = instance("", _ + _)
  
  /** Int monoid with addition */
  given intAdditionMonoid: Monoid[Int] = instance(0, _ + _)
  
  /** List monoid with concatenation */
  given [A] => Monoid[List[A]] = instance(Nil, _ ++ _)
  
  /** Option monoid (first Some wins, None is identity) */
  given [A] => Monoid[Option[A]] = instance(None, {
    case (Some(a), _) => Some(a)
    case (None, b) => b
  })
  
  /** Boolean monoid with conjunction (AND) */
  val booleanAndMonoid: Monoid[Boolean] = instance(true, _ && _)
  
  /** Boolean monoid with disjunction (OR) */
  val booleanOrMonoid: Monoid[Boolean] = instance(false, _ || _)
}